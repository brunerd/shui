#!/bin/zsh
#!/bin/bash
#shui (20220704) - a zsh/bash function to add Applescript user interaction to your macOS (10.9+) script 

#this script includes demonstration code, use it to test syntax out or run the demo function with: "./shui demo", for help see "./shui help"
#to use in your script: copy and paste ONLY the function shui {...} into your script, for reduced line count use shui.min

#hold the Shift key down for xtrace debugging when you run this script
shiftKeyDown="$(osascript -l JavaScript -e "ObjC.import('Cocoa'); ($.NSEvent.modifierFlags & $.NSEventModifierFlagShift) > 1" 2>/dev/null)"
#false may be because "false" if new NS constants are not recognized (10.11 and below)
[ "${shiftKeyDown}" = "false" ] && shiftKeyDown="$(osascript -l JavaScript -e "ObjC.import('Cocoa'); ($.NSEvent.modifierFlags & $.NSShiftKeyMask) > 1" 2>/dev/null)"
#osascript 10.10 and under cannot handle Javascript yet, fall back to python if unset
[ -z "${shiftKeyDown}" ] && shiftKeyDown="$(/usr/bin/python -c 'import Cocoa; print Cocoa.NSEvent.modifierFlags() & Cocoa.NSShiftKeyMask > 1')"

#set xtraceFlag if /tmp/debug found or Command key is held down
[ -f /tmp/debug ] || [ "$shiftKeyDown" = "true" ] || [ "$shiftKeyDown" = "True" ] && xtraceFlag=1
[ -n "$xtraceFlag" ] && set -x

############
# FUNCTION #
############

## BEGIN SHUI FUNCTION ##
function shui(){
#turn xtrace off temporarily
[ -n "${-//[^x]/}" ] && { local xTrace=1; set +x; } 2>/dev/null
local version="20220704"
: <<-EOL
shui - a zsh/bash function to easily add Applescript user interaction to your script (https://github.com/brunerd/shui)
Copyright (c) 2020 Joel Bruner
MIT License
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
EOL

######################
## Conditional Exits #
######################

#10.8 and under are a no-go, 10.9+ only
[ "$(cut -d. -f1 <<< $(sw_vers -productVersion))" -eq 10 -a "$(cut -d. -f2 <<< $(sw_vers -productVersion))" -le 8 ] && echo "shui requires macOS 10.9 and above" >&2 && return 1 

#if the silentMode or shui_silentMode flag is set to Y return
[ "${shui_silentMode}" = "Y" ] || [ "${silentMode}" = "Y" ] && return

##############
## VARIABLES #
##############

#we unset these GLOBAL variables each time the function is entered (use -v to have them output to stdout)
unset lastButton lastText lastChoice lastGaveUp lastCancel lastError lastResult lastPID

## Use global var or overwrite with hard coded values
#Unix path or App Bundle accepted (if they contsain icns, RIP in Big Sur)
local defaultIcon="${shui_defaultIcon}"

#default title - process escaped text then escape \ and "
[ -n "${shui_defaultTitle}" ] && local defaultTitle="$(echo -e "${shui_defaultTitle}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')"

#default "default Option" for buttons (name or number) or for file/folder (default file path)
[ -n "${shui_defaultOption}" ] && local defaultOption="$(echo -e "${shui_defaultOption}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')"

#timeout is how long Applescript waits before not listening anymore (window stays, not same as giveup which dissapears), defaults to 3 days (max time) if this is unset
local timeoutSecondsAppleScript=${shui_timeoutDefault:-"133200"}

#default to a calling app to own the Applescript window, this will cause an initial permission pop-up dialog in 10.14+
# the calling app will also be unable to do anything within until the window is dismissed
local defaultApplication="${shui_defaultApplication}"

#if we are picking colors default to this
local defaultColorRGB="${shui_defaultColor:-65535,65535,65535}" #white

######################
# COMPUTED VARIABLES #
######################

#get console user UID
local consoleUserID="$(stat -f %u /dev/console)"

#get console user name
local consoleUser="$(stat -f %Su /dev/console)"

#a few shell specific settings depending on where this function finds itself
if [ -n "$ZSH_VERSION" ]; then
	#bash like word splitting behavior
	set -y
elif [ -n "$BASH_VERSION" ]; then	
	#bash arrays start at zero 
	local array_offset="1"
	
	#unset getopts variables each time
	unset OPTIND OPTARG
fi

#command to run in the console user bootstrap context AND as the user context
#necessary to accept text input with console user's keyboard localization
local asuserPrefix="launchctl asuser ${consoleUserID} sudo -u ${consoleUser}"

#10.9 and 10.10 launchctl asuser only runs as root
if [ "$(cut -d. -f1 <<< $(sw_vers -productVersion))" -eq 10 ] && [ "$(cut -d. -f2 <<< $(sw_vers -productVersion))" -le 10 ]; then
	#unset if we are the console user
	if [ "${USER}" = "${consoleUser}" ]; then
		unset asuserPrefix
	#early macOS versions got touchy about this
	elif [ "${USER}" != "${consoleUser}" ] && [ "$UID" -ne 0 ] && [ "${SUDO_USER}" != "${consoleUser}" ]; then
		echo "Script user ($USER) ≠ console user ($consoleUser), please run as root on 10.10 and 10.9" >&2
		return 1
	fi
fi

#used to store the Applescript
local APPLESCRIPT 

read -r -d '' helpText <<'EOT'
shui (20220704) - add Applescript user interaction to your shell script (https://github.com/brunerd/shui)\n\nUsage:\nshui [<UI Type>] -p "<prompt text>" \n\nUI Types:\nalert: alert with icon of the calling appication (use -a), prompt (-p) is bold, message text (-P) is smaller, can set level (-L) to critical\napplication: presents list of Launch Services registered applicatins can specify -m for multiple\nbutton (default): button based reply, use -b to change button names (max 3), defaults to "Cancel,OK" like Applescript does\ncolor: no options, presents color picker and returns "R,G,B" with individual values (0-65535)\nfile: pick one file or multiple (-m), -d for default folder, -P to specify preferred file extensions or UTIs, -h hidden items, -s show bundle contents\nfolder: pick one file or multiple (-m), -d for default folder, -P to specify preferred file extensions, -h hidden items, -s show bundle contents\nlist: pick one or mutiple (-m) items from a list of choices, use -D for custom delimiter (comma default)\ntext: like button but with a single line text entry box, set pre-filled text with -P, hidden text with -h\nurl: returns a URL, default is file servers, use -S to set the kind of server to look for, valid value listed below\n\nRequired:\n-p "prompt text"\talert/button/file/folder/list: the text prompt presented to the user, required for all type (except color)\n\nOptions (begins with UI type(s) which apply or "all"):\n\n-a "<application>"\tall (except filename): specify the application that will present the Applescript dialog, alert will have app icon and block app\n\n-b "<button>;...;..."\tbutton: max 3 button names, comma or semi-colon delimited (if commas AND semi-colons are present, semis "win") \n\t\t\t\t\t\tif no buttons specified it defaults to the standard Applescript "Cancel,OK"\n-b "<OK>,[<Cancel>]"\tlist: max 2 button names, comma delimited, first is the OK button name, second is Cancel button name (optional)\n\n-B "n"\t\t\tall: beep n number of times\n\n-c "name/number"\tbutton: specify the cancel button by name or number (use with alert and buttons named "Cancel")\n\n-d "name/number"\tbutton: default button name or number (0 will suppress Applescript OK button default if -b not specified)\n-d "<Folder Path>"\tfile/folder: default location (Unix Path), using ~ will resolve to the console user's home folder\n\n-D "<delimiter>"\tlist: Delimiter for -l list items, can specify literal character like $'\\n' or use these two named shortcuts "LF" "IFS"\n\n-e \t\t\tlist: allow empty selection\n\n-g "seconds"\t\talert/button: give-up timeout in seconds (dismisses windows and moves on)\n\n-h\t\t\ttext: hidden text entry (dots)\n-h\t\t\tfile/folder: show hidden files in picker\n\n-i "<path>"\t\tbutton: path to icon file or application bundle (Icon^M first, then Info.plist)\n\n-l "item,item,..."\tlist: items for list, comma delimited is default unless newline is detected (change delimiter with -D)\n\n-L "<level>"\t\talert: default is "informational"/"warning" (same), "critical" adds a caution sign over the calling app (-a) icon\n\n-m\t\t\tapplication/file/folder/list: allow multiple selections\n\n-n\t\t\talert/button: non-Blocking window, spawns to a background and moves on, response is not captured, one button maximum\n \t\t\tNote: If this is NOT the last alert window it is advisable to use a giveup (-g) value, additional dialogs will occlude previous ones (use -X to clear)\n\n-N\t\t\talert/button: same as (-n) non-blocking window except button 1 is default\n\n-o\t\t\tall: output shell arguments, Applescript code and raw Results and Errors\n\n-P "message text"\talert: "parenthetical" message text below the bold prompt text\n-P "<R>,<G>,<B>"\tcolor: pre-chosen RGB color values 0-65535\n-P "filename"\t\tfilename: pre-filled file name (default folder set with -d)\n-P "extension,UTI,..."\tfile: "preferred" file extensions/UTIs available to choose in picker\n-P "item,item..."\tlist: pre-chosen items, default delimiter is comma unless a newline is present or can be set with -D\n-P "pre-fill text"\ttext: pre-filled text (may be hidden with -h)\n\n-S "<Service>"\t\turl: look for specific services, useful values are: "file" (default) and "web" \n\t\t\tLess useful but still valid values are: "ftp", "media", "telnet", "news", "remote" (applications), and "directory" (services)\n\n-s\t\t\tfile/folder: show package/bundle contents (as a folder basically)\n\n-t "Title text"\t\tbutton/list/text: window title\n\n-v\t\t\tall: output results in format suitable for initializing shell variables\n-V\t\t\tall: output results in format suitable for initializing shell variables plus Applescript and raw Result/Error output from osascript (-o)\n\n-X\t\t\talert/button: kill ALL osascript and "System Events" processes, like orphaned non-Blocking (background) windows. Use with CAUTION!\n-x\t\t\talert/button: kill only child osascript processes belonging to the running script (embedded usage only)\n\nshui sets these GLOBAL variables within the script's running context (use -v to output these if shui is standalone/non-embedded):\n\tlastButton - value of button from button, text, and list replies\n\tlastText   - Text string from text reply\n\tlastChoice - File or Folder Unix path from files/filename/folders\n\tlastGaveUp - true or false, button and text reply types only, when a give up (-g) value is specified\n\tlastCancel - true or false, since Cancel produces an error and no result this helps determine if clicked\n\tlastResult - full Result output (stdout) from osascript that is parsed into the above values\n\tlastError  - full Error (stderr) output from osascript\n\tlastPID    - the child PID of a non-blocking (-n) alert or button (excluding -a invoked)\n\nshui will use these GLOBAL variables set in your script or exported in your running shell\n\tshui_defaultIcon - icon path for button UIs\n\tshui_defaultTitle - title string for button, text, and list UIs\n\tshui_defaultOption - button by name or number or file/folder by path\n\tshui_defaultColor - default color (picker) UI "<R>,<G>,<B>" 0-65535
EOT

####################
## Process Options #
####################

if [ -z "${1}" ]; then
	echo -e "No arguments given!\nFor usage: shui help\nFor examples: shui demo" >&2
	return 1
elif [ "${1}" = "help" ]; then 
	echo "${helpText}" >&2
	return 0
elif [ "${1}" = "version" ]; then 
	echo "${version}"
	return 0
elif [ "$(cut -c1-1 <<< ${1})" = "-" ]; then
		local uiType="button"
else
	#normalize uiType to lower case
	local uiType="$(tr "[[:upper:]]" "[[:lower:]]" <<< "${1}")"
	shift 1
fi

# a leading : colon turns on SILENT error reporting
# https://stackoverflow.com/questions/16483119/example-of-how-to-use-getopts-in-bash

local option; while getopts ":B:L:t:g:P:p:i:b:c:D:S:d:l:a:nehmNsovVXx" option; do

	case "${option}" in
		'a')local applicationNameArg="${OPTARG}";;
		'b')local buttonListArgs="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";; #escape \ and "
		'B')local beep_AS="beep ${OPTARG}";;
		'c')local cancelButton="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";; #escape quotes
		'd')local defaultOption="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";;
		'D')local listDelimiter="${OPTARG}";;
		'e')local withEmpty_AS="with empty selection allowed";;
		'g')local giveupSeconds="${OPTARG}";;
		'h')local option_h_flag="1";;
		'i')local iconArgument="${OPTARG}";;
		'L')local alertLevel_AS="as ${OPTARG}";;
		'l')local listItems="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";;
		'm')local withMultiple_AS="with multiple selections allowed";;
		'n')local nonBlockingFlag="1";;
		'N')local nonBlockingFlag="1";
			local defaultOption="1";;
		'o')local outputFlag="1";;
		'p')local promptString="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')" #escape quotes
			local withPrompt_AS="with prompt \"${promptString}\"";;
		'P')local preFillString="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";; #escape quotes
		'S')local serviceArgument="${OPTARG}";;
		's')local showingPackage_AS="with showing package contents";;
		't')local titleString="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";; #escape quotes
		'v')local variableFlag="1";;
		'V')local variableFlag="1"
			local outputFlag="1"
			local variableFlagPlus="1";;
		#these are mutually exclusive
		'X')[ -z "${killChildProcsOnly}" ] && local killAllProcs="1";;
		'x')[ -z "${killAllProcs}" ] && local killChildProcsOnly="1";;
	esac
done

#if we don't have a promptString at the minimum then exit (unless this is for a color or url)
if [ -z "${promptString}" ] && [ "${uiType}" != "color" ] && [ "${uiType}" != "url" ]; then
	echo "Please provide prompt text in the form of: shui <UI Type> -p \"<prompt text>\"\nFor usage: shui help\nFor examples: shui demo" >&2
	return
fi

#if we have a default application and nothing is specified, use it
if [ -z "${applicationNameArg}" ] && [ -n "${defaultApplication}" ]; then
	local applicationNameArg="${defaultApplication}"
fi

#if we have a default icon (and it exists) and nothing is specified for -i, use it
if [ -z "${iconArgument}" ] && [ -e "${defaultIcon}" ]; then
	local iconArgument="${defaultIcon}"
fi

#color seems needs an application, use System Events if not specified
if [ "${uiType}" = "color" ] && [ -z "$applicationNameArg" ]; then
	local applicationNameArg="System Events"
fi

#if we have set an application 
if [ -n "${applicationNameArg}" ]; then
	#used to default to "System Events"
	local tellApp_AS="tell application \"${applicationNameArg}\""
	local endTell_AS="end tell"
fi

#applies only to: text, password, button
#if no -t "titleString" specified, use default (as set by env var $shui_defaultTitle)
[ -z "${titleString}" ] && [ -n "${defaultTitle}" ] && local titleString="${defaultTitle}"

#see what kind of window we need to show and ready buttons and Applescript code
case "${uiType}" in
	"list")		
		#zsh doe not like += assignments to a local prefixed variable, sp define these as local here
		local listItems_AS preChosenList_AS listArray preChosenArray button_OK button_cancel

		if [ -z "${listItems}" ]; then
			echo -e "No data for list!\nSpecify list data with: -l \"<data>\"\nDefault delimiter comma (,) can be changed with -D \"<char>\""
			return 1
		fi
		
		#list, button, text - can have a title
		[ -n "$titleString" ] && local title_AS="with title \"$titleString\""
		
		## Buttons
		#lists have a different methods of defining buttons, you define an named button and a Cancel button only
		#you can only choose 2 buttons they will default to OK and Cancel if empty (as Applescript does)
		if [ -n "${buttonListArgs}" ]; then
			#if we have 2 or more newlines then we are using newlines for button name delimiters (1 is present in a single string tested with herestring)
			if [ "$(grep -c $'\n' <<< "${buttonListArgs}")" -ge 2 ]; then
				#line 1
				local button_OK="$(sed -n 1p <<< "${buttonListArgs}")"
				#line 2
				local button_cancel="$(sed -n 2p <<< "${buttonListArgs}")"
			else
				#if there is a semi-colon delimit with that otherwise use semi-colon
				[ "$(grep -c $';' <<< "${buttonListArgs}")" -ge 1 ] && local buttonDelimiter=';' || local buttonDelimiter=',' 
				
				#field 1
				local button_OK="$(cut -d "${buttonDelimiter}" -f1 <<< "${buttonListArgs}")"
				#field 2
				local button_cancel="$(cut -d "${buttonDelimiter}" -f2 <<< "${buttonListArgs}")"
				#if only one button name is specified then cut will set both to be the same. If so, unset it and it will default to Cancel
				[ "${button_cancel}" = "${button_OK}" ] && button_cancel=""
			fi		
		fi
		
		## List Creation
		#if we have defined a delimiter by label "IFS", "LF" or with the actual delimiter(s) do that
		if [ "${listDelimiter}" = "IFS" ]; then
			IFS=$' \n\t' listArray=( ${listItems} )
		elif [ "${listDelimiter}" = "LF" ]; then
			IFS=$'\n' listArray=( ${listItems} )
		elif [ -n "${listDelimiter}" ]; then
			IFS=${listDelimiter} listArray=( ${listItems} )
		#otherwise set a delimiter based on content
		else
			#since a list cannot handle multi-line items
			#if we have 2 or more newlines then we are using newlines for item delimiters (1 is present in a single string tested with herestring)
			if [ "$(grep -c $'\n' <<< "${listItems}")" -ge 2 ]; then
				IFS=$'\n' listArray=( ${listItems} )
			#default to commas
			else
				IFS=, listArray=( ${listItems} )
			fi
		fi
		
		#concatenate array into ", " delimited  string
		#arrayoffset allows both bash and zsh arrays to work correctly
		for (( j=$(( 1 - ${array_offset:-0} )); j <= $(( ${#listArray[@]} - ${array_offset:-0} )); j++ )); do
			[ -z "$listItems_AS" ] && listItems_AS+="\"${listArray[$j]}\"" || listItems_AS+=", \"${listArray[$j]}\""
		done

		## Pre-Chosen Items
		#if we have pre-chosen choices
		if [ -n "$preFillString" ]; then
			#create Applescript for pre-chosen items 
			#default to comma delimiting
			if [ "${listDelimiter}" = "IFS" ]; then
				IFS=$' \n\t' preChosenArray=( ${preFillString} )
			elif [ "${listDelimiter}" = "LF" ]; then
				IFS=$'\n' preChosenArray=( ${preFillString} )
			elif [ -n "${listDelimiter}" ]; then
				IFS=${listDelimiter} preChosenArray=( ${preFillString} )
			#otherwise set a delimiter based on content
			else
				#since a list cannot handle multi-line items
				#if we have 2 or more newlines then we are using newlines for item delimiters (1 is present in a single string tested with herestring)
				if [ "$(grep -c $'\n' <<< "${preFillString}")" -ge 2 ]; then
					IFS=$'\n' preChosenArray=( ${preFillString} )
				#default to commas
				else
					IFS=, preChosenArray=( ${preFillString} )
				fi
			fi

			#concatenate array into ", " delimited  string
			#arrayoffset allow both bash and zsh arrays to work correctly
			for (( j=$(( 1 - ${array_offset:-0} )); j <= $(( ${#preChosenArray[@]} - ${array_offset:-0} )); j++ )); do
				[ -z "${preChosenList_AS}" ] && preChosenList_AS+="\"${preChosenArray[$j]}\"" || preChosenList_AS+=", \"${preChosenArray[$j]}\""
				#simple thing to limit list to 1 if we have not selected multiple items
				[ -z "${withMultiple_AS}" ] && break
			done
			
			local defaultItems_AS="default items {${preChosenList_AS}}"
		fi
		
		#generate the applescript and assign to variable using read and a heredoc
		#https://stackoverflow.com/questions/1167746/how-to-assign-a-heredoc-value-to-a-variable-in-bash
		read -r -d '' APPLESCRIPT <<-EOF
			${tellApp_AS}
				activate
				${beep_AS}
				with timeout of $timeoutSecondsAppleScript seconds
					set dialogAnswer to choose from list {${listItems_AS}} ${withMultiple_AS} ${title_AS} ${withPrompt_AS} ${defaultItems_AS} ${withEmpty_AS} OK button name {"${button_OK:-OK}"} cancel button name {"${button_cancel:-Cancel}"}
					if class of dialogAnswer is boolean then
						error number -128
					end if
					if (count of dialogAnswer) is greater than 1 then
						set dialogAnswers to ""
						repeat with choice from 1 to count of dialogAnswer
							set theCurrentItem to item choice of dialogAnswer
							set dialogAnswers to dialogAnswers & theCurrentItem & "\n"
						end repeat
					else
						return dialogAnswer as string
					end if
				end timeout
			${endTell_AS}
			EOF
	;;		
	"file"*|"folder")

		#show hidden/invisible files
		local option_h_flag
		[ "${option_h_flag:=0}" -eq 1 ] && local withInvisibles_AS="with invisibles"

		#validate the provided default location
		if [ -d "${defaultOption}" ]; then
			local folderPath="${defaultOption}"
		#if this is a home folder relative path then try and resolve it
		elif [ "${defaultOption:0:1}" = '~' ]; then
			#sudo has some quirks, this avoids them
			local homeFolder="$(dscl . -read /Users/$consoleUser NFSHomeDirectory | awk -F ": " '{print $NF}')"
			local folderPath="${homeFolder}${defaultOption:1}"
		#if zsh...
		elif [ -n "${ZSH_VERSION}" ]; then
			#get path to folder containing calling script even for zsh 5.3 and under - http://people.apache.org/~danielsh/zsh/mhonarc-test-20180920001/workers-2018/msg00008.html
			local folderPath="$(dirname "${ZSH_ARGZERO:=${${funcfiletrace[-1]}[(ws/:/)1]}}")"
		#in bash $0 is the script path (in some versionss of zsh this is the function name)
		elif [ -e "${0}" ]; then
			local folderPath="$(dirname "$0")"
		#otherwise fall back to the current folder
		else
			local folderPath="$(pwd)"
		fi

		case "${uiType}" in
		"filename")
			if [ -n "${preFillString}" ]; then
				local defaultNameString="default name \"$preFillString\""
			fi

			#ask user for file name to save as, OS will give the Replace warning if existing file is picked
			#note this does not return an alias but of "class furl" this will cause issues if System Events is the application
			#workaround is to not specify an application (however we do lose the ability to set timeout because of that)

			#generate the applescript and assign to variable using read and a heredoc
			read -r -d '' APPLESCRIPT <<-EOF
			${beep_AS}
			get POSIX path of (choose file name ${defaultNameString} ${withPrompt_AS} default location POSIX file "$folderPath")
			EOF
		;;
		"file"|"folder")		
			#turn comma delimited string of allowed file types into Applescript style list: {"A", "B", "C"}
			if [ -n "${preFillString}" ]; then
				local choice;
				local fileTypeList;
				IFS=,
				for choice in $preFillString; do
					#if first entry do not prefix with comma, otherwise put comma in front
					[ -z "$fileTypeList" ] && fileTypeList=\"$choice\" || fileTypeList+=,\ \"$choice\"
				done
				IFS=$' \n\t'
			
				#this will narrow the scope of allowed file types
				local ofType_AS="of type {$fileTypeList}"
			fi
		
			#generate the applescript and assign to variable using read and a heredoc
			read -r -d '' APPLESCRIPT <<-EOF
			${tellApp_AS}
				activate
				${beep_AS}
				with timeout of $timeoutSecondsAppleScript seconds
					set dialogAnswer to choose ${uiType} ${withInvisibles_AS} ${withPrompt_AS} ${ofType_AS} ${withMultiple_AS} default location POSIX file "${folderPath}" ${showingPackage_AS}
					#for multiple selections
					if class of dialogAnswer is list then
						set dialogAnswers to ""
						repeat with thisAlias from 1 to count of dialogAnswer
							set dialogAnswers to dialogAnswers & POSIX path of item thisAlias of dialogAnswer & "\n"
						end repeat
					#for a single choice
					else if class of dialogAnswer is alias then
						set dialogAnswer to POSIX path of dialogAnswer
					end if
				end timeout
			${endTell_AS}
			EOF
			
		;;
		esac
	;;
	"application"*)

		#generate the applescript and assign to variable using read and a heredoc
		read -r -d '' APPLESCRIPT <<-EOF
		${tellApp_AS}
			activate
			${beep_AS}
			with timeout of $timeoutSecondsAppleScript seconds
				set dialogAnswer to choose application ${title_AS} ${withPrompt_AS} ${withMultiple_AS} as alias
				if class of dialogAnswer is list then
					set dialogAnswers to ""
					repeat with thisAlias from 1 to count of dialogAnswer
						set dialogAnswers to dialogAnswers & POSIX path of item thisAlias of dialogAnswer & "\n"
					end repeat
				else if class of dialogAnswer is alias then
					set dialogAnswer to POSIX path of dialogAnswer
				end if
			end timeout
		${endTell_AS}
		EOF
	;;		
	"color")
		#if we have specified a value only use it if it is valid
		if [ -n "${preFillString}" ] ; then
			local R="$(cut -d, -f1 <<< "${preFillString}")"
			local G="$(cut -d, -f2 <<< "${preFillString}")"
			local B="$(cut -d, -f3 <<< "${preFillString}")"
			#make sure each RGB value is between 0 and 65535
			if [ "${R}" -ge 0 ] && [ "${R}" -le 65535 ] && [ "${G}" -ge 0 ] && [ "${G}" -le 65535 ] && [ "${B}" -ge 0 ] && [ "${B}" -le 65535 ]; then		
				defaultColor_AS="default color {${preFillString}}"
			fi
		elif [ -n "${defaultColorRGB}" ]; then
			defaultColor_AS="default color {${defaultColorRGB}}"
		fi
		
		#generate the applescript and assign to variable using read and a heredoc
		read -r -d '' APPLESCRIPT <<-EOF
			${tellApp_AS}
				activate
				${beep_AS}
				with timeout of $timeoutSecondsAppleScript seconds
					set theColor to choose color ${defaultColor_AS}
				end timeout
			${endTell_AS}
			EOF
	;;
	"url")
		#if we have a value..
		if [ -n "${serviceArgument}" ]; then
			#translate the one word parameter to it's Applescript equivalent
			case "${serviceArgument}" in
				"file") local servicename_AS="File servers";;
				"web") local servicename_AS="Web servers";;
				"ftp") local servicename_AS="FTP Servers";;
				"media") local servicename_AS="Media servers";;
				"telnet") local servicename_AS="Telnet hosts";;
				"news") local servicename_AS="News servers";;
				"remote") local servicename_AS="Remote applications";;
				"directory") local servicename_AS="Directory services";;
			esac
			
			[ -n "${servicename_AS}" ] && showingService_AS="showing ${servicename_AS}"
		fi
			
		#generate the applescript and assign to variable using read and a heredoc
		read -r -d '' APPLESCRIPT <<-EOF
		${tellApp_AS}
			activate
			${beep_AS}
			with timeout of $timeoutSecondsAppleScript seconds
				choose URL ${showingService_AS}
			end timeout
		${endTell_AS}
		EOF
	;;
	"alert"|"button"|"text"|*)

		##Titles and Prompts
		#some special handling for titles and prompts
		case "${uiType}" in
			"alert")
				#since we are sharing with button/text
				local windowType="alert"
		
				#use the -P text for "parenthetical" message text 
				#for an alert the "prompt" (promptString) is the BOLD portion (almost like a title)
				[ -n "${preFillString}" ] && local message_AS="message \"${preFillString}\""
			;;
			"button"|"text")
				#only the button/text case cares about the windowtype so it's OK if this is set and it's list, app, etc...
				local windowType="dialog"
				
				#unset alert only options for applescript
				unset alertLevel_AS

				#alerts cannot have a title
				[ -n "$titleString" ] && local title_AS="with title \"$titleString\""
			;;
			*)
				echo -e "Unknown UI Type: \"${uiType}\"\nFor usage: shui help\nFor examples: shui demo" >&2
				return 1
			;;
		esac
		
		## Buttons
		#if non-blocking option -n limit to one since nothing is listening to a background process and multiple option imply something is listening
		#otherwise limit to three buttons max
		[ -z "${nonBlockingFlag}" ] && local buttonCountLimit=3 || local buttonCountLimit=1

		#non-blocking with no buttons default to OK (otherwise we just take the first button for NB)
		if [ -z "$buttonListArgs" ] && [ -n "${nonBlockingFlag}" ]; then
			local buttonListArgs="OK"
		fi
		
		#if we have 2 or more newlines then we are using newlines for name delimiters (1 is present in a single string tested with herestring)
		if [ "$(grep -c $'\n' <<< "$buttonListArgs")" -ge 2 ]; then
			IFS=$'\n'
		#if we use semicolons and commas are not used either, delimit with semi-colons
		elif [ "$(grep -c ';' <<< "$buttonListArgs")" -ge 1 ]; then
			IFS=$';'
		else
		#otherwise default to commas
			IFS=,
		fi
		
		#button list creation
		local button buttonListItems buttonCount
		for button in ${buttonListArgs}; do
			#dangling delimiter? Skip it.
			[ -z "${button}" ] && continue
			#trim off leading or trailing spaces
			button="$(sed "s/^[ ]*//;s/[ ]*$//" <<< "${button}" )"
			#if first entry do not prefix with comma, otherwise put comma in front
			[ -z "${buttonListItems}" ] && buttonListItems=\"${button}\" || buttonListItems+=,\ \"${button}\"
			#increment button Count
			let $((buttonCount++))
			#stop if we've reached the limit
			[ "${buttonCount:=1}" -ge "${buttonCountLimit}" ] && break
		done
		
		#set it back
		IFS=$' \n\t'
		
		[ -n "${buttonListItems}" ] && buttons_AS="buttons {${buttonListItems}}"
		
		#if we have a -d default button specified... see if it's a number
		if [ -n "${defaultOption}" ] && [ "${defaultOption}" = "$(bc 2>/dev/null <<< "${defaultOption}")" ]; then
			#ensure it's between 1 less than or equal to the total button
			if [ "${defaultOption}" -ge 1 ] && [ "${defaultOption}" -le "${buttonCount}" ]; then
				local defaultButton_AS="default button ${defaultOption}"
			fi			
		#otherwise if we have a button name see if it is the button list items (-n reduces list to 1 item)
		elif [ -n "${defaultOption}" ] && [ -n "$(grep -w "${defaultOption}" <<< "${buttonListItems}")" ]; then
			local defaultButton_AS="default button \"${defaultOption}\""
		fi

		#if we have a cancel button specified... see if it's a number
		if [ -n "${cancelButton}" ] && [ "${cancelButton}" = "$(bc 2>/dev/null <<< "${cancelButton}")" ]; then
			#ensure it's between 1 less than or equal to the total button
			if [ "${cancelButton}" -ge 1 ] && [ "${cancelButton}" -le "${buttonCount}" ]; then
				local cancelButton_AS="cancel button ${cancelButton}"
			fi			

		#otherwise make sure we have something and it matches a button name
		elif [ -n "${cancelButton}" ] && [ -n "$(grep -w "${cancelButton}" <<< "${buttonListArgs}")" ]; then
			local cancelButton_AS="cancel button \"${cancelButton}\""
		fi
		
		## Icons
		#if the icon argument is a file and this is not an alert
		if [ -f "${iconArgument}" ] && [ "${uiType}" != "alert" ]; then
			#convert unix path to Applescript
			local withIcon_AS="with icon file (POSIX file \"${iconArgument}\")"
		#if this is NOT a valid path (and it's not an alert) let's see what else it could be
		elif [ ! -f "${iconArgument}" ] && [ "${uiType}" != "alert" ]; then
			#check if we are given a name or a path of some kind for an icon
			case "${iconArgument}" in
				"stop"|"0")
				
					#if no app then this is System Event with cannot show a "stop" icon
					if [ -z "${applicationNameArg}" ] || [ "${applicationNameArg}" = "System Events" ]; then
						#alert icon to pass to alertUserConsole
						local alertIconUnixPath="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertStopIcon.icns"
					#otherwise any other app will overlay their icon over the stop sign
					else
						local alertIconName="stop"
					fi
					
				;;
				"caution"|"2")
					#if no app of System Events show a plain unbadged "caution" icon
					if [ -z "${applicationNameArg}" ] || [ "${applicationNameArg}" = "System Events" ]; then
						
						#I tried with AlertCautionBadgeIcon.icns on 11+ but it is too small to be taken seriously
						#local alertIconUnixPath="$(find "/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/" -name 'AlertCaution*Icon.icns' | sort -r | head -n 1)"
						local alertIconUnixPath="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertCautionIcon.icns"
						#RIP AlertCautionIcon.icns it moved into /System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/Assets.car
						#Problem Reporter.app has something similar if AlertCautionIcon.icns is gone
						[ ! -f "${alertIconUnixPath}" ] && alertIconUnixPath="/System/Library/CoreServices/Problem Reporter.app/Contents/Resources/ProblemReporter.icns"
					#otherwise any other app will overlay their icon over the stop sign
					else
						local alertIconName="caution"
					fi

				;;
				"note"|"1")
					#if no app then this is System Event with cannot show a "note" icon
					if [ -z "${applicationNameArg}" ] || [ "${applicationNameArg}" = "System Events" ]; then
						#alert icon to pass to alertUserConsole
						local alertIconUnixPath="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertNoteIcon.icns"
					#otherwise any other app will overlay their icon over the stop sign
					else
						local alertIconName="note"
					fi

				;;	
				#everything else
				*)
					#check for old school Icon^M
					if [ -f "${iconArgument}/Icon"$'\r' ]; then
						#for cleanup later
						local tempIcon="/tmp/shuiTemp-${RANDOM}.icns"
						#hex the ResourceFork as ASCII
						local resourceHexString="$(xattr -p com.apple.ResourceFork "${iconArgument}/Icon"$'\r')"
						#remove first 260 bytes (3 ASCII chars) (why? I haven't looked too hard)
						[ -n "${resourceHexString}" ] && xxd -r -p - <<< "${resourceHexString:780}" > "${tempIcon}"
						#as long as the result is NOT "data" attempt to use this as an icon
						if [ -s "${tempIcon}" ] && [ -z "$(grep ": data" <<< "$(file "${tempIcon}")")" ]; then local alertIconUnixPath="${tempIcon}"; fi
					fi					

					#if alertIconUnixPath is empty (no Icon^M), see if this is a bundle with an Info.plist and interogate
					if [ -f "${iconArgument}"/Contents/Info.plist ] && [ -z "${alertIconUnixPath}" ]; then
						local bundleIconFileName="$(defaults read "${iconArgument}"/Contents/Info.plist CFBundleIconFile 2>/dev/null)"
						[ -z "${bundleIconFileName}" ] && bundleIconFileName="$(defaults read "${iconArgument}"/Contents/Info.plist CFBundleIconName 2>/dev/null)"
						
						#append icns if it does not have that as an extension (Apple apps like Finder do not)
						[ "${bundleIconFileName}" = "${bundleIconFileName/.icns/}" ] && bundleIconFileName="${bundleIconFileName}".icns
		
						local bundleIconPath="${iconArgument}"/Contents/Resources/"${bundleIconFileName}"
		
						#if this icon exists use it
						if [ -f "${bundleIconPath}" ]; then
							local alertIconUnixPath="${bundleIconPath}"
						else
						#other use the default if it doesn't pan out
							local alertIconUnixPath="${defaultIcon}"
						fi
					fi
				;;
			esac

			#if we came out with a file that exists use it
			if [ -f "${alertIconUnixPath}" ]; then
				local withIcon_AS="with icon file (POSIX file \"${alertIconUnixPath}\")"
			elif [ -n "${alertIconName}" ]; then
				local withIcon_AS="with icon ${alertIconName}"
			fi
		fi

		#hidden text (dots)
		local option_h_flag
		[ "${option_h_flag:=0}" -eq 1 ] && local withHiddenAnswer_AS="with hidden answer"

		#it makes no sense for a non-Blocking window to allow text entry, so just ignore
		if [ -n "${nonBlockingFlag}" ] && [ "${uiType}" = "text" ]; then
			unset nonBlockingFlag
		fi
		
		#simply specifying a 'default answer' is enough to add text entry to a button dialog
		if [ "${uiType}" = "text" ]; then
			local defaultAnswer_AS="default answer \"$preFillString\""
		fi
		
		#if blank and default is specified, use it 
		if [ -z "${iconArgument}" ] && [ -n "${defaultIcon}" ]; then
			local iconArgument="${defaultIcon}"
		fi
		
		#allow use of relative paths
		if [ "${iconArgument:0:1}" = '~' ]; then
			#sudo has some quirks, this avoids them
			local homeFolder="$(dscl . -read /Users/$consoleUser NFSHomeDirectory | awk -F ": " '{print $NF}')"
			local iconArgument="${homeFolder}${iconArgument:1}"
		fi
		
		#if giveup is specified make Applescript string
		[ -n "${giveupSeconds}" ] && local giveup_AS="giving up after \"$giveupSeconds\""
		
		if [ -n "${nonBlockingFlag}" ]; then
			#background style windows are single button only, no text, since results cannot be captured
			#generate the applescript and assign to variable using read and a heredoc
			read -r -d '' APPLESCRIPT <<-EOF
			${tellApp_AS}
				activate
				${beep_AS}
				with timeout of $timeoutSecondsAppleScript seconds
					set dialogAnswer to display ${windowType} "${promptString}" ${alertLevel_AS} ${message_AS} ${title_AS} ${withIcon_AS} ${buttons_AS} ${giveup_AS} ${defaultButton_AS} ${cancelButton_AS}
				end timeout
			${endTell_AS}
			EOF
		else
			#generate the applescript with the text reply kind of window since background is not appropriate to capture input
			read -r -d '' APPLESCRIPT <<-EOF
			${tellApp_AS}
				activate
				${beep_AS}
				with timeout of $timeoutSecondsAppleScript seconds
					set dialogAnswer to display ${windowType} "${promptString}" ${alertLevel_AS} ${message_AS} ${defaultAnswer_AS} ${withHiddenAnswer_AS} ${title_AS} ${withIcon_AS} ${buttons_AS} ${giveup_AS} ${defaultButton_AS} ${cancelButton_AS}
				end timeout
			${endTell_AS}
			EOF
		fi
	;;
esac

#output the command if flagged for it
if [ -n "${outputFlag}" ]; then
	local a invocationQuoted
	#a few shell specific settings depending on where this function finds itself
	if [ -n "${ZSH_VERSION}" ]; then
		#zsh puts arguments in an array when called both from CLI and from another function (demo)
		#so this way we can put quotes around the arguments
		for ((a=1; a <= ${#argv[@]}; a++ )); do
			#if it is an option flag no quotes otherwise quote it
			[ "${argv[$a]:0:1}" = '-' ] && invocationQuoted+="${argv[$a]} " || invocationQuoted+="'${argv[$a]}' "
		done
	elif [ -n "${BASH_VERSION}" ]; then
		#if called from another function (non-CLI) bash does not put arguments into ARGV array
		if [ "${BASH_ARGC:-0}" -eq 1 ]; then
			#we will just output without quotes (trying to quote input is troublesome)
			local invocationQuoted="$@"
		else
			#minus 2 because bash arrays are 0 based plus skip the first arg
			for ((a=$((${BASH_ARGC:-0}-2)); a >= 0; a-- )); do
				[ "${BASH_ARGV[$a]:0:1}" = '-' ] && invocationQuoted+="${BASH_ARGV[$a]} " || invocationQuoted+="'${BASH_ARGV[$a]}' "
			done
		fi
	fi
	#output the arguments used
	echo -e "Arguments:\n${uiType} ${invocationQuoted}\n" >&2
fi

#output the applescript removing empty lines
[ -n "$outputFlag" ] && (echo "Applescript:" >&2; cat <<< "$APPLESCRIPT" | sed '/^$/d' >&2; echo >&2)

#-X big hammer - kill all System Events and osascript procs
if [ -n "${killAllProcs}" ]; then
	local sysEventsPID osascriptPID
	#loop through all PIDs and kill -9 as the console user
	for sysEventsPID in $(pgrep System\ Events); do eval ${asuserPrefix} kill -9 "${sysEventsPID}"; done
	for osascriptPID in $(pgrep osascript); do eval ${asuserPrefix} kill -9 "${osascriptPID}"; done
fi

#-x little hammer - only kill System Events and osascript procs belonging to the calling script (only for embedded shui, not standalone, use -X)
if [ -n "${killChildProcsOnly}" ]; then
	local sysEventsPID osascriptPID childPID
	local childPIDs="$(pgrep -P $$)"
	
	#loop through all child PIDs
	for childPID in $(pgrep -P $$); do 
		local grandChildPID="$(pgrep -P $childPID)"
		#get the process name
		local grandChildPIDString="$(ps ${grandChildPID} | tail -n +2)"
		#if the child process ends with osascript proceed
		if grep -q "osascript$" <<< "${grandChildPIDString}"; then
			#this process may still one process away because of sudo usage
			if grep -q "sudo$" <<< "$(pgrep -laP $childPID)"; then
				local childPIDToKill="$(pgrep -P $grandChildPID)"
			else
				local childPIDToKill="${grandChildPID}"
			fi
		fi
		[ -n "${childPIDToKill}" ] && eval ${asuserPrefix} kill -9 "${childPIDToKill}"
	done
fi

#execute the applescript and capture the result
if [ -z "${nonBlockingFlag}" ]; then
	##put the $$ current PID in name for easier cleanup if trap set in calling script
	local tempStdErrFile="/tmp/shuiError-$$-${RANDOM}.txt"
	#eval will always return 0 if parsing went well, so we cannot capture the exit/status code of osascript
	#set these two new global vars, non-blocking does not get these
	lastResult="$(eval ${asuserPrefix} /usr/bin/osascript 2>${tempStdErrFile} <<< "$APPLESCRIPT")"
	lastError="$(< "${tempStdErrFile}")"
	#clean up
	rm "${tempStdErrFile}"
	#for -v/-V output inside $''
	#escape \n only if present (otherwise nothing) and/or then escape the backslash \
	[ $(( $(wc -l <<< "${lastError}") )) -gt 1 ] && local lastError_escaped="$(sed -e 's/\\/\\\\/g' -e :a -e N -e '$!ba' -e 's/\n/\\n/g' <<< "${lastError}")" || local lastError_escaped="$(sed -e 's/\\/\\\\/g' <<< "${lastError}")"
	#escape whitespace \b \f \r \t \v and single quote '
	lastError_escaped="$(sed -e $'s/\r/\\\\r/g' -e $'s/\t/\\\\t/g' -e $'s/\b/\\\\b/g' -e $'s/\f/\\\\f/g' -e $'s/\v/\\\\v/g' -e $'s/\'/\\\\\'/g' <<< "${lastError_escaped}")"
else
	#if running in the background just eval without capturing output or stderr
	{ ( eval ${asuserPrefix} /usr/bin/osascript &>/dev/null <<< "$APPLESCRIPT"; [ -e "${tempIcon}" ] && rm -f "${tempIcon}" ) & }
	
	local childPID=$!
	#pause a beat, if too quick the child processes will not exist yet
	sleep .2
	local grandChildPID="$(pgrep -P ${childPID})"

	#only if the granchild PID exists proceed and this was not -a targetted
	if [ -n "${grandChildPID}" ] && [ -z "${tellApp_AS}" ]; then
		if grep -q "sudo$" <<< "$(pgrep -laP $childPID)"; then
			lastPID="$(pgrep -P $grandChildPID)"
		else
			lastPID="${grandChildPID}"
		fi
	fi
fi

#only go through the effort if they clicked a button
if [ -n "${lastResult}" ]; then
	#for -v/-V output inside $''
	#escape \n only if present (otherwise nothing) and/or then escape the backslash \
	[ $(( $(wc -l <<< "${lastResult}") )) -gt 1 ] && local lastResult_escaped="$(sed -e 's/\\/\\\\/g' -e :a -e N -e '$!ba' -e 's/\n/\\n/g' <<< "${lastResult}")" || local lastResult_escaped="$(sed -e 's/\\/\\\\/g' <<< "${lastResult}")"
	#escape whitespace \b \f \r \t \v and single quote '
	lastResult_escaped="$(sed -e $'s/\r/\\\\r/g' -e $'s/\t/\\\\t/g' -e $'s/\b/\\\\b/g' -e $'s/\f/\\\\f/g' -e $'s/\v/\\\\v/g' -e $'s/\'/\\\\\'/g' <<< "${lastResult_escaped}")"

	#this copy will be truncated as it is parsed
	local lastResultFragment_escaped="${lastResult_escaped}"

	#parse lastResult and assign to global variables
	case "${uiType}" in
		"alert"|"button"|"text")
			#alert/button/text
			
			#if give up specified get that result (otherwise unset) and strip
			if [ -n "${giveup_AS}" ]; then
				#get the last GaveUp
				if grep -q "gave up:true$" <<< "${lastResultFragment_escaped}"; then
					lastGaveUp="true"
				else
					lastGaveUp="false"
				fi
		
				#trim off the LAST ",gave up:true|false"
				lastResultFragment_escaped=$(sed -e 's/, gave up:true$//' -e 's/, gave up:false$//' <<< "${lastResultFragment_escaped}")
			fi
			
			#NOTE: alert, button, and text ALL return "button returned:" when a non-Cancel button is clicked
			#ONLY alert can return "Cancel" as a string but by default it will only display OK (unlike dialog or list which include Cancel)
			#you can set the Cancel button with -c on an alert so it will have the same behavior as dialog and text (but it cannot be a highlighted default)
			#example returns: 'button returned:Cancel, gave up:false' (but we trim 'gave up') so just  'button returned:Cancel' at this point
			local lastButton_escaped="$(awk -F '^button returned:|, text returned:' '{print $2}' <<< "${lastResultFragment_escaped}")"
			#set this to false, even if we made an alert with a Cancel button (could be in another language)
			lastCancel="false"
			
			#unescape what's left by eval'ing string inside and $''
			eval lastButton=\$\'"${lastButton_escaped}"\'
					
			#trim "button returned:" from the beginning of string
			lastResultFragment_escaped="$(sed -e 's/^button returned:'"${lastButton_escaped//\\/\\\\}"'//' <<< "${lastResultFragment_escaped}")"

			#if text is returned
			if grep -q "^, text returned:" <<< "${lastResultFragment_escaped}"; then
			#sample osaresult='button returned:OK, text returned:myTest, is here, gave up:false'
				#use | or operator with -F field to buttress your matches, using only , was not robust enough
				local lastText_escaped="$(sed -e 's/^, text returned://' <<< "${lastResultFragment_escaped}")"

				#unescape what's left by eval'ing string inside and $''
				eval lastText=\$\'"${lastText_escaped}"\'
			fi
		;;
		# all the other types do not need parsing
		"file"*|"folder"|"application"|"color"|"url"|*)
			#the choice we made
			lastChoice="${lastResult}"
			#Icon^M custom icon files have a traling carriage return \r in the filename etc..
			#escape \n only if present (otherwise nothing) and/or then escape the backslash \
			[ $(( $(wc -l <<< "${lastChoice}") )) -gt 1 ] && local lastChoice_escaped="$(sed -e 's/\\/\\\\/g' -e :a -e N -e '$!ba' -e 's/\n/\\n/g' <<< "${lastChoice}")" || local lastChoice_escaped="$(sed -e 's/\\/\\\\/g' <<< "${lastChoice}")"
			#escape whitespace \b \f \r \t \v and single quote '
			lastChoice_escaped="$(sed -e $'s/\r/\\\\r/g' -e $'s/\t/\\\\t/g' -e $'s/\b/\\\\b/g' -e $'s/\f/\\\\f/g' -e $'s/\v/\\\\v/g' -e $'s/\'/\\\\\'/g' <<< "${lastChoice_escaped}")"
			lastCancel="false"
		;;
	esac
elif [ "${uiType}" = "url" ] && [ -z "${lastError}" ]; then
	lastCancel="false"
#this will catch the list cancel
elif [ -z "${nonBlockingFlag}" ]; then
	lastCancel="true"
fi

#remove temp icon if it exists and NOT non-blocking 
[ -e "${tempIcon}" ] && [ -z "${nonBlockingFlag}" ] && rm -f "${tempIcon}"

#-o and -V will output the raw osascript Results and Errors to stderr to not interfere with -v output
if [ -n "${outputFlag}" ] || [ -n "${variableFlagPlus}" ]; then  
	printf "Result:\n%s\n\n" "${lastResult}" >&2
	printf "Error:\n%s\n\n" "${lastError}" >&2
fi

#if -v flag is set, output variables to stderr so one could do something like: eval "$(shui button -v -p "Test" -b "Yes,No")"
if [ -n "${variableFlag}" ]; then
	#-v will output to stdout
	#/usr/bin does not process escaped characters like \n \r \t that shell built-in echo may (shell dependent)
	#buttons should not contain these chars but just in case
	/bin/echo "lastButton=\$'${lastButton_escaped}'"
	/bin/echo "lastText=\$'${lastText_escaped}'"
	/bin/echo "lastChoice=\$'${lastChoice_escaped}'"
	#ONLY true/false IF an alert or button AND give up (-g) has been specified 
	/bin/echo "lastGaveUp='${lastGaveUp}'"
	#NOT from Applescript but sure helps to have boolean for Cancel status
	/bin/echo "lastCancel='${lastCancel}'"
	#raw output
	/bin/echo "lastResult=\$'${lastResult_escaped}'"
	/bin/echo "lastError=\$'${lastError_escaped}'"
	#final child PID from a non-blocking alert/button
	/bin/echo "lastPID='${lastPID}'"
fi

#if cancelled or had ANY error output: return non-zero for a shell fail
[ -n "${lastError}" ] || [ "${lastCancel}" = "true" ] && return 1
}

## END SHUI FUNCTION ##

##########################################################################################
# TEST FUNCTIONS #
##########################################################################################

function button_demo {
shui button -p "Specify icons by specific file, the .app bundle or with keywords \"stop\", \"caution\", and \"note\"\nDefault buttons can be specified by name or number..." -b "OK,Cool,Cancel" -d "Cool" -t "Your Title Here" -i "/System/Library/CoreServices/Finder.app" -V

#lastCancel is set to true/false every time shui is invoked, also for single buttons with comma use a trailing semi-colon
[ "${lastCancel}" = "true" ] && shui button -p "You clicked Cancel!" -i "stop" -t "Cancel Clicked" -b "Yes, I did;" -d1

shui button -p "You can specify a cancel button by name (Skip) or number (3)\nCancel will return NO button results when clicked\nYou can also use the \$lastCancel variable\n\nClick Skip for Cancel detection" -b "This,That,Skip" -d 1 -c 3 -i "caution" -V

#lastCancel is set to true/false every time shui is invoked, also for single buttons with comma use a trailing semi-colon
[ "${lastCancel}" = "true" ] && shui button -p "You clicked Cancel!" -i "stop" -t "Cancel Clicked" -b "Yes, I did;" -d1

shui button -p "Specifying a give up time (-g) makes a nice pop-up that alerts but moves on after a while..." -g "10" -b "OK" -d 1 -t "Title" -i "/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/Clock.icns" -V

multiLineText="You can put lots of text in a window

• For a list of things to tell a user
• Please Make sure you realize...
	° This
	° That
	° The other

\"Cool\", right?"

#you can use mutliline variables to neatly compose your invocation
shui button -p "${multiLineText}" -b "Yes,No,Maybe" -t "Greetings" -i "caution" -d "Yes" -V
}

#unencode emoji work just fine also (just not on Jamf)
function 1emoji_demo {
multiLineText="shui works with Unicode™ and Emoji 

\0342\0234\0205 Dialogs, buttons, pre-fills, etc...

Note: Multibyte emojis in Jamf Pro scripts MUST be encoded, you may reliably use these encoding schemes

UTF-8 \\\\xhh Hex encoding:
\\\\xf0\\\\x9f\\\\x98\\\\x8e = \xf0\x9f\x98\x8e

UTF-8 \\\\0nnn Octal encoding:
\\\\0360\\\\0237\\\\0230\\\\0216 = \0360\0237\0230\0216

Unicode characters can be encoded using jpt the JSON Power Tool: https://github.com/brunerd/jpt
"

#you can use mutliline variables to neatly compose your invocation
shui button -p "${multiLineText}" -b "\0360\0237\0237\0242 Yes,\xf0\x9f\x9b\x91 No,\0342\0232\0240\0357\0270\0217Maybe" -t "\xf0\x9f\x93\xa3 Greetings \xf0\x9f\x94\x8a" -i "caution" -d "\xf0\x9f\x9f\xa2 Yes" -V
}

function text_demo {
#single line, pre-filled answers are returned on give-up
shui text -p "Question for you, 15 seconds though!\nNote: It will return the pre-fill after timeout, lastGaveUp will be true" -P "Pre-Filled Answer" -t "Title" -i "/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/Actions.icns" -b "Send,Save,Trash" -d 1 -c 3 -g 15 -V

#passwords benefit from being hidden
shui text -p "Hidden Input with Pre-Filled answer...\nSpecifying an app brings focus and icon keywords will badge the app icon" -h -P "secr3t" -t "Password Prompt" -i "stop" -b "Submit,Cancel" -d 1 -V -a Terminal

#multi-line windows are possible if you padd the pre-fill with newlines ending with a space or any other character(s), "\n" are evaluated as LF or you can use $'\n'
#FYI: text entry window will NOT have scroll bars
shui text -p "Please tell us what you REALLY think:" -P "\n\n\n " -t "Multi-Line Text Responses"  -b "Cancel,Comment" -d 2 -V

#buttons with commas are possible and automatically recognized when a newline is present
shui text -p "You can put commas in buttons if you delimit with newlines\n\nLack of default button ensures accidentally hitting Return does not move on..." -i "note" -t "Title" -b "OK, Boomer"$'\n'"Cancel" -V
}

function list_demo {
#first button name is for "OK" button, the second if for the cancel button
shui list -p "Choose One, custom buttons" -l "This,That,Other" -t "Title"  -b 'Remove,Skip' -P "Other" -V

#while the list choice demiliters default to comma, you can specify a custom delimiter like LF if you need to used commas
local bunchaChoices="This has commas, neato!
This one too, wow"
shui list -p "Items have commas by using custom delimiter, buttons can include commas if newlines used" -l "$bunchaChoices" -t "Title" -b 'Remove, Please'$'\n''Ignore' -D $'\n' -P "This one too, wow" -V

#while the list choice demiliters default to comma, you can specify a custom delimiter like space if you want
local bunchaChoices="true false truthy"
shui list -p "Choose One or none from space delimited list with custom delimiter" -l "$bunchaChoices" -t "Custom Title" -b 'Pick,Pass' -D " " -e -V

#a single button name will be used for the "OK" button
shui list -p "Choose One or More (Custom Buttons) with Shift or Command clicking" -m -l "Eenie,Meanie,Minie,Moe" -t "Title" -b 'Choose' -P "Eenie,Moe" -V

#buttons default to "OK, Cancel"
shui list -p "Choose One or More with Shift or Command clicking" -m -l "This,That,Other" -t "Title" -V

#allowing commas in a list mean changing the delimiter to $'\n' from ,
local bunchaChoices="This has commas, neato!
This one too, wow
I will forget Applescript after using this"
shui list -p "Choose One or More (Custom buttons) with Shift or Command clicking" -m -l "$bunchaChoices" -t "Title" -b 'Yep,Nope' -D $'\n' -V
}

function file_demo {
#pick a file or folder, defaults to where the script is running
shui file -p "Pick a file inside an app or package bundle" -d '/System/Library/CoreServices' -s -V

#pick a file or folder, defaults to where the script is running
shui file -p "Pick a hidden file..." -h -d '~' -V

#pick a file or folder, defaults to where the script is running
shui file  -p "Pick multiple files using Shift and Command keys..." -m -V

#specify allowed mixed UTI file extensions (-f) and a default folder to look with (-d)
shui file -p "Pick a public.image or txt file only" -m -P 'public.image,txt' -d '~/Pictures' -V

#specify an allowed file extension (-f) and a folder to look with (-t)
shui file -p "Pick a .log or .out files only" -m -P 'log,out' -d "/var/log" -V
}

function folder_demo {
#pick multiple folders, will resolve ~ relative paths for the console user
shui folder -p "Pick some folders from your Desktop..." -m -d '~/Desktop' -V

#specify an a default directory to look in with -d and inside
shui folder -p "Pick a folder inside an Application" -s -d "/Applications" -V

#pick a file or folder, defaults to where the script is running
shui folder -p "Pick a folder, origin of current script if not specified..." -h -V

#specify a default directory to look in with -d 
shui folder -p "Pick folders starting at root" -m -d "/" -V
}

function alert_demo {
shui alert -p "Alert Prompt" -P "Alerts do not have titles, the prompt text will be bolder though\nThe icon will be the application specified with -a or a folder if no application is specified\nThis is an info/warning level alert (default)..." -b "OK" -d 1 -V

shui alert -p "Bold Alert Prompt" -P "The critical alert level overlays the application icon with a caution sign" -b "This,That,Cancel" -d 1 -c 3 -L "critical" -V

shui alert -p "Specify an application with the -a option" -P "The icon is jazzed up but this will inhibit any other action in the app until dismissed and may require additional PPPC permissions" -b "OK," -d 1 -a "Terminal" -L "critical" -V
}

function znonBlockingButton-System_Events_demo {
#timeout
shui button -a "System Events" -p "Non-blocking window (-n) with give up of 10 seconds, the script proceeds (not blocked) and no values are returned\n\nNote: Give up time will affect subsequent System Events windows if this is still open...\n" -b "Wait for it..." -g 10 -i "caution" -n -V
echo "Script proceeding, sleeping 5 seconds..."
sleep 5
shui button -a "System Events" -p "Like this one...\nThis one will get the time out from the previous window, so only specify -a \"System events\" if you want to be able to kill the non-blocking window later..." -b "Uh oh" -g 10 -i "caution" -V
echo "Script proceeding, sleeping 5 seconds..."
sleep 5
shui button -a "System Events" -p "This window is now covering a window that is stuck... and this has a give up of 1 hour BUT it can be killed along with all other System Events based windows with -X\n\nWait for it... (10 seconds)" -b "Wait for it..." -g 3600 -i "stop" -d 1 -n -V
echo "Script proceeding, sleeping 10 seconds..."
sleep 10
shui button -p 'BOOM!\nAnonymous windows and those with System Events as the application (-a) can be cleared with -X\n' -X -b "OK" -V -N -i "/System/Library/CoreServices/Finder.app"
echo "Script proceeding, sleeping 5 seconds..."
sleep 5
shui alert -p "Alerts can be non-Blocking too" -P "If you specify any OTHER app besides System Events with -a they CANNOT be killed with -X or -x" -N  -L "critical" -B 1 -X
echo "Script proceeding, sleeping 7 seconds..."
sleep 7
}

function znonBlockingButton-Anonymous_demo {
#timeout
shui button -p "Non-blocking windows (-n) WITHOUT a specified app (-a) will NOT block each other but they WILL still stack up on top of each other.\n\nClick OK to spawn 3 pop-ups\n\nNote: You can't get results back from non-blocking buttons and alerts" -b "OK" -i "/System/Library/CoreServices/Finder.app" -V
shui button -n -p "One non-blocking window..." -b "OK" -i "stop" -V
sleep 2
shui button -n -p "Two non-blocking windows..." -b "OK" -i "caution" -V
sleep 2
shui button -n -p "Three non-blocking windows!!!" -b "OK" -i "note" -V
sleep 2
shui button -p "Look under this window there are 3 other windows.Click Close All to close these windows with (-x) which ONLY closes osascript child processes in this script" -b "Close All" -i "stop" -V
shui button -x -p "Boom. That killed all the windows.\n\n-X kills ALL osascript and System Event processes but -x is much more targetted and requires shui to be embedded for best results\n\nlastPID is a new global var for your script to track non-Blocking PIDs" -b "OK" -i "/System/Library/CoreServices/Finder.app" -V
}


function application_demo {
#timeout
shui application -p "Pick one application..." -t "App Picker" -V

#timeout
shui application -p "Pick one or more applications using the Shift and Command keys..." -m -t "Multi-App Picker" -V
}

function url_demo {
#URL defaults to "file" servers if no service specified (-S)
shui url -V

#URL with service specified
shui url -S "web" -V
}

function color_demo {
shui color -V

shui color -P "12000,30000,45000" -V
}

function filename_demo {
#pick a file or folder, defaults to where the script is running
shui filename -p "Pick a file name to Save As..." -d '~/Desktop' -P "PrePopulated_Name-$RANDOM.txt" -V
}

function Q_and_A_demo {
shui text -p 'Hi! What is your name?' -d "OK" -t "shui demo" -V
local myName="${lastText:-Unknown}"

shui button -p "Good to meet you ${myName}, which do you prefer?" -b "Day,Night,Both" -V
local timeOfDayPref="${lastButton}"

shui list -p "Are any of these are your favorite fruits?" -l "Apples,Bananas,Blueberries,Kiwi Fruit,Jack Fruit,Durian,Sugar Cane" -m -V -e
local myFruitsRAW="${lastChoice}"
#count the lines, ensure line is not empty as the wc -l method always return 1 or greater, otherwise it is zero
[ -n "${myFruitsRAW}" ] && local myFruitsLines="$(wc -l <<< "$(sed -e '/^$/d' <<< "$myFruitsRAW")" | sed -e 's/^[ ]*//g')" || local myFruitsRAW=0

if [ "${myFruitsLines}" -eq 0  ]; then
	s=""
	isare="is"
	myFruits="None"
elif [ "${myFruitsLines}" -eq 1  ]; then
	s=""
	isare="is"
	myFruits="${myFruitsRAW}"
else
	s="s"
	isare="are"
	myFruits="$(sed -e :a -e N -e '$!ba' -e 's/\n/, /g'<<< "${myFruitsRAW}")"
fi

shui alert -p "Here are my findings, $myName" -P "Your preference of day or night is: $timeOfDayPref
Your favorite fruit${s} ${isare}: ${myFruits}" -b "OK" -d 1
}

function testMenu {
#if this is zsh proceed (substitution style is zsh only)
if [ -n "${ZSH_NAME}" ]; then
	#http://people.apache.org/~danielsh/zsh/mhonarc-test-20180920001/workers-2018/msg00008.html
	#get path to self even for zsh 5.3 and under
	local myPath="${ZSH_ARGZERO:=${${funcfiletrace[-1]}[(ws/:/)1]}}"
#in bash this will be the script (in zsh this is the function name)
elif [ -e "${0}" ]; then
	local myPath="$0"
fi

#build our list of function names ending in "_demo"
testFunctionsList="$(grep ^function "${myPath}" | grep "_demo" | awk '{print $2}' | sort -df)"
while :; do
	#the main menu using -x to kill any background windows
	shui list -D "LF" -l "${testFunctionsList}" -b "Run,Exit" -p "Pick one or more test functions to run..." -t "shui" -m -x
	#if it's empty quit (2nd button in list is ALWAYS Cancel) otherwise invoke the function
	if [ -z "${lastChoice}" ]; then
		exit
	else
		for function in ${lastChoice}; do
			"$function"
		done
	fi
done

#if it was on before, turn xtrace back on
[  "${xTrace:-0}" = 1 ] && { set -x; } 2>/dev/null
}

########
# MAIN #
########

case ${1} in
	"menu"|"demo")
		#make a menu of all the test functions
		testMenu
		;;
	*)
		#pass-through all arguments
		shui "$@"
		;;
esac
