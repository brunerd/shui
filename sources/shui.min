#!/bin/zsh
#!/bin/bash
#shui - a zsh/bash function to add Applescript user interaction to your macOS (10.9+) script 

#this script includes demonstration code, use it to test syntax out or run the demo function with: "./shui demo", for help see "./shui help"
#to use in your script: copy and paste ONLY the function shui {...} into your script, for reduced line count use shui.min

#hold the Shift key down for xtrace debugging when you run this script
shiftKeyDown="$(osascript -l JavaScript -e "ObjC.import('Cocoa'); ($.NSEvent.modifierFlags & $.NSEventModifierFlagShift) > 1" 2>/dev/null)"
#false may be because "false" if new NS constants are not recognized (10.11 and below)
[ "${shiftKeyDown}" = "false" ] && shiftKeyDown="$(osascript -l JavaScript -e "ObjC.import('Cocoa'); ($.NSEvent.modifierFlags & $.NSShiftKeyMask) > 1" 2>/dev/null)"
#osascript 10.10 and under cannot handle Javascript yet, fall back to python if unset
[ -z "${shiftKeyDown}" ] && shiftKeyDown="$(/usr/bin/python -c 'import Cocoa; print Cocoa.NSEvent.modifierFlags() & Cocoa.NSShiftKeyMask > 1')"

#set xtraceFlag if /tmp/debug found or Command key is held down
[ -f /tmp/debug -o "$shiftKeyDown" = "true" -o "$shiftKeyDown" = "True" ] && xtraceFlag=1
[ -n "$xtraceFlag" ] && set -x

## BEGIN SHUI FUNCTION ##
function shui {
local version="20210420"
: <<-EOL
shui.min - a zsh/bash function to easily add Applescript user interaction to your script (https://github.com/brunerd/shui)
Copyright (c) 2020 Joel Bruner
MIT License
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
EOL
#these GLOBAL vars are reset each time shui runs
unset lastButton lastText lastChoice lastGaveUp lastCancel lastError lastResult lastPID
[ "${shui_silentMode}" = "Y" -o "${silentMode}" = "Y" ] && return; [ "$(cut -d. -f1 <<< $(sw_vers -productVersion))" -eq 10 -a "$(cut -d. -f2 <<< $(sw_vers -productVersion))" -le 8 ] && echo "shui requires macOS 10.9 and above" >&2 && return 1; local defaultIcon="${shui_defaultIcon}";[ -n "${shui_defaultTitle}" ] && local defaultTitle="$(echo -e "${shui_defaultTitle}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";[ -n "${shui_defaultOption}" ] && local defaultOption="$(echo -e "${shui_defaultOption}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')"; local timeoutDefault="${shui_timeoutDefault}"; local defaultApplication="${shui_defaultApplication}"; local defaultColorRGB="${shui_defaultColor:-65535,65535,65535}"; local timeoutSecondsAppleScript=${timeoutDefault:-"133200"};local consoleUserID="$(stat -f %u /dev/console)";local consoleUser="$(stat -f %Su /dev/console)"; if [ -n "$ZSH_VERSION" ]; then set -y; elif [ -n "$BASH_VERSION" ]; then local array_offset="1"; unset OPTIND OPTARG; fi;local NL=$'\n';local asuserPrefix="launchctl asuser ${consoleUserID} sudo -u ${consoleUser}";if [ "$(cut -d. -f1 <<< $(sw_vers -productVersion))" -eq 10 -a "$(cut -d. -f2 <<< $(sw_vers -productVersion))" -le 10 ]; then if [ "${USER}" = "${consoleUser}" ]; then unset asuserPrefix; elif [ "${USER}" != "${consoleUser}" -a "$UID" -ne 0 -a "${SUDO_USER}" != "${consoleUser}" ]; then echo "Script user ($USER) ≠ console user ($consoleUser), please run as root on 10.10 and 10.9" >&2;return 1;fi;fi;local APPLESCRIPT
read -r -d '' helpText <<'EOT'
shui - add Applescript user interaction to your shell script (https://github.com/brunerd/shui)\n\nUsage:\nshui [<UI Type>] -p "<prompt text>" \n\nUI Types:\nalert: alert with icon of the calling appication (use -a), prompt (-p) is bold, message text (-P) is smaller, can set level (-L) to critical\napplication: presents list of Launch Services registered applicatins can specify -m for multiple\nbutton (default): button based reply, use -b to change button names (max 3), defaults to "Cancel,OK" like Applescript does\ncolor: no options, presents color picker and returns "R,G,B" with individual values (0-65535)\nfile: pick one file or multiple (-m), -d for default folder, -P to specify preferred file extensions or UTIs, -h hidden items, -s show bundle contents\nfolder: pick one file or multiple (-m), -d for default folder, -P to specify preferred file extensions, -h hidden items, -s show bundle contents\nlist: pick one or mutiple (-m) items from a list of choices, use -D for custom delimiter (comma default)\ntext: like button but with a single line text entry box, set pre-filled text with -P, hidden text with -h\nurl: returns a URL, default is file servers, use -S to set the kind of server to look for, valid value listed below\n\nRequired:\n-p "prompt text"\talert/button/file/folder/list: the text prompt presented to the user, required for all type (except color)\n\nOptions (begins with UI type(s) which apply or "all"):\n\n-a "<application>"\tall (except filename): specify the application that will present the Applescript dialog, alert will have app icon and block app\n\n-b "<button>;...;..."\tbutton: max 3 button names, comma or semi-colon delimited (if commas AND semi-colons are present, semis "win") \n\t\t\t\t\t\tif no buttons specified it defaults to the standard Applescript "Cancel,OK"\n-b "<OK>,[<Cancel>]"\tlist: max 2 button names, comma delimited, first is the OK button name, second is Cancel button name (optional)\n\n-B "n"\t\t\tall: beep n number of times\n\n-c "name/number"\tbutton: specify the cancel button by name or number (use with alert and buttons named "Cancel")\n\n-d "name/number"\tbutton: default button name or number (0 will suppress Applescript OK button default if -b not specified)\n-d "<Folder Path>"\tfile/folder: default location (Unix Path), using ~ will resolve to the console user's home folder\n\n-D "<delimiter>"\tlist: Delimiter for -l list items, can specify literal character like $'\\n' or use these two named shortcuts "LF" "IFS"\n\n-e \t\t\tlist: allow empty selection\n\n-g "seconds"\t\talert/button: give-up timeout in seconds (dismisses windows and moves on)\n\n-h\t\t\ttext: hidden text entry (dots)\n-h\t\t\tfile/folder: show hidden files in picker\n\n-i "<path>"\t\tbutton: path to icon file or application bundle (Icon^M first, then Info.plist)\n\n-l "item,item,..."\tlist: items for list, comma delimited is default unless newline is detected (change delimiter with -D)\n\n-L "<level>"\t\talert: default is ‌"informational"/"‌warning" (same), "critical" adds a caution sign over the calling app (-a) icon\n\n-m\t\t\tapplication/file/folder/list: allow multiple selections\n\n-n\t\t\talert/button: non-Blocking window, spawns to a background and moves on, response is not captured, one button maximum\n \t\t\tNote: If this is NOT the last alert window it is advisable to use a giveup (-g) value, additional dialogs will occlude previous ones (use -X to clear)\n\n-N\t\t\talert/button: same as (-n) non-blocking window except button 1 is default\n\n-o\t\t\tall: output shell arguments, Applescript code and raw Results and Errors\n\n-P "message text"\talert: "parenthetical" message text below the bold prompt text\n-P "<R>,<G>,<B>"\tcolor: pre-chosen RGB color values 0-65536\n-P "filename"\t\tfilename: pre-filled file name (default folder set with -d)\n-P "extension,UTI,..."\tfile: "preferred" file extensions/UTIs available to choose in picker\n-P "item,item..."\tlist: pre-chosen items, default delimiter is comma unless a newline is present or can be set with -D\n-P "pre-fill text"\ttext: pre-filled text (may be hidden with -h)\n\n-S "<Service>"\t\turl: look for specific services, useful values are: "file" (default) and "web" \n\t\t\tLess useful but still valid values are: "ftp", "media", "telnet", "news", "remote" (applications), and "directory" (services)\n\n-s\t\t\tfile/folder: show package/bundle contents (as a folder basically)\n\n-t "Title text"\t\tbutton/list/text: window title (can be hardcoded)\n\n-v\t\t\tall: output results in format suitable for initializing shell variables\n-V\t\t\tall: output results in format suitable for initializing shell variables plus Applescript and raw Result/Error output from osascript (-o)\n\n-X\t\t\talert/button: kill ALL osascript and "System Events" processes, like orphaned non-Blocking (background) windows. Use with CAUTION!\n-x\t\t\talert/button: kill only child osascript processes belonging to the running script (embedded usage only)\n\nshui sets these GLOBAL variables within the script's running context (use -v to output these if shui is standalone/non-embedded):\n\tlastButton - value of button from button, text, and list replies\n\tlastText   - Text string from text reply\n\tlastChoice - File or Folder Unix path from files/filename/folders\n\tlastGaveUp - true or false, button and text reply types only, when a give up (-g) value is specified\n\tlastCancel - true or false, since Cancel produces an error and no result this helps determine if clicked\n\tlastResult - full Result output (stdout) from osascript that is parsed into the above values\n\tlastError  - full Error (stderr) output from osascript\n\tlastPID    - the child PID of a non-blocking (-n) alert or button (excluding -a invoked)
EOT
if [ -z "${1}" ]; then echo -e "No arguments given!\nFor usage: shui help\nFor examples: shui demo" >&2; return 1;elif [ "${1}" = "help" ]; then echo "${helpText}" >&2;return 0;elif [ "${1}" = "version" ]; then echo "${version}"; return 0;elif [ "$(cut -c1-1 <<< ${1})" = "-" ]; then local uiType="button";else local uiType="$(tr "[[:upper:]]" "[[:lower:]]" <<< "${1}")";shift 1;fi;local option;while getopts ":B:L:t:g:P:p:i:b:c:D:S:d:l:a:nehmNsovVXx" option; do case "${option}" in 'a')local applicationNameArg="${OPTARG}";;'b')local buttonListArgs="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";;'B')local beep_AS="beep ${OPTARG}";;'c')local cancelButton="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";; 'd')local defaultOption="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";;'D')local listDelimiter="${OPTARG}";;'e')local withEmpty_AS="with empty selection allowed";;'g')local giveupSeconds="${OPTARG}";;'h')local option_H_flag="1";;'i')local iconArgument="${OPTARG}";;'L')local alertLevel_AS="as ${OPTARG}";;'l')local listItems="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";;'m')local withMultiple_AS="with multiple selections allowed";;'n')local nonBlockingFlag="1";;'N')local nonBlockingFlag="1";local defaultOption="1";;'o')local outputFlag="1";;'p')local promptString="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')"; local withPrompt_AS="with prompt \"${promptString}\"";;'P')local preFillString="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";;'S')local serviceArgument="${OPTARG}";;'s')local showingPackage_AS="with showing package contents";;'t')local titleString="$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')";;'v')local variableFlag="1";;'V')local variableFlag="1";local outputFlag="1";local variableFlagPlus="1";;'X')[ -z "${killChildProcsOnly}" ] && local killAllProcs="1";;'x')[ -z "${killAllProcs}" ] && local killChildProcsOnly="1";;esac;done;if [ -z "${promptString}" -a "${uiType}" != "color" -a "${uiType}" != "url" ]; then echo "Please provide prompt text in the form of: shui <UI Type> -p \"<prompt text>\"\nFor usage: shui help\nFor examples: shui demo" >&2;return;fi;if [ -z "${applicationNameArg}" -a -n "${defaultApplication}" ]; then local applicationNameArg="${defaultApplication}"; fi; if [ -z "${iconArgument}" -a -n "${defaultIcon}" ]; then local iconArgument="${defaultIcon}"; fi;if [ "${uiType}" = "color" -a -z "$applicationNameArg" ]; then local applicationNameArg="System Events"; fi;if [ -n "${applicationNameArg}" ]; then local tellApp_AS="tell application \"${applicationNameArg}\"";local endTell_AS="end tell";fi;case "${uiType}" in "list") local listItems_AS preChosenList_AS listArray preChosenArray button_OK button_cancel;if [ -z "${listItems}" ]; then echo -e "No data for list!\nSpecify list data with: -l \"<data>\"\nDefault delimiter comma (,) can be changed with -D \"<char>\"";return 1;fi;if [ -n "${buttonListArgs}" ]; then if [ "$(grep -c $'\n' <<< "${buttonListArgs}")" -ge 2 ]; then local button_OK="$(sed -n 1p <<< "${buttonListArgs}")";local button_cancel="$(sed -n 2p <<< "${buttonListArgs}")";else [ "$(grep -c $';' <<< "${buttonListArgs}")" -ge 1 ] && local buttonDelimiter=';' || local buttonDelimiter=',';local button_OK="$(cut -d "${buttonDelimiter}" -f1 <<< "${buttonListArgs}")";local button_cancel="$(cut -d "${buttonDelimiter}" -f2 <<< "${buttonListArgs}")";[ "${button_cancel}" = "${button_OK}" ] && local button_cancel="";fi;fi;if [ "${listDelimiter}" = "IFS" ]; then IFS=$' \n\t' listArray=( ${listItems} ); elif [ "${listDelimiter}" = "LF" ]; then IFS=$'\n' listArray=( ${listItems} ); elif [ -n "${listDelimiter}" ]; then IFS=${listDelimiter} listArray=( ${listItems} );else if [ "$(grep -c $'\n' <<< "${listItems}")" -ge 2 ]; then IFS=$'\n' listArray=( ${listItems} );else IFS=, listArray=( ${listItems} );fi;fi;for (( j=$(( 1 - ${array_offset:-0} )); j <= $(( ${#listArray[@]} - ${array_offset:-0} )); j++ )); do [ -z "$listItems_AS" ] && listItems_AS+="\"${listArray[$j]}\"" || listItems_AS+=", \"${listArray[$j]}\"";done;if [ -n "$preFillString" ]; then if [ "${listDelimiter}" = "IFS" ]; then IFS=$' \n\t' preChosenArray=( ${preFillString} );elif [ "${listDelimiter}" = "LF" ]; then IFS=$'\n' preChosenArray=( ${preFillString} ); elif [ -n "${listDelimiter}" ]; then IFS=${listDelimiter} preChosenArray=( ${preFillString} ); else if [ "$(grep -c $'\n' <<< "${preFillString}")" -ge 2 ]; then IFS=$'\n' preChosenArray=( ${preFillString} );else IFS=, preChosenArray=( ${preFillString} );fi;fi;for (( j=$(( 1 - ${array_offset:-0} )); j <= $(( ${#preChosenArray[@]} - ${array_offset:-0} )); j++ )); do [ -z "${preChosenList_AS}" ] && preChosenList_AS+="\"${preChosenArray[$j]}\"" || preChosenList_AS+=", \"${preChosenArray[$j]}\"";[ -z "${withMultiple_AS}" ] && break;done;local defaultItems_AS="default items {${preChosenList_AS}}";fi
read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set dialogAnswer to choose from list {${listItems_AS}} ${withMultiple_AS} ${title_AS} ${withPrompt_AS} ${defaultItems_AS} ${withEmpty_AS} OK button name {"${button_OK:-OK}"} cancel button name {"${button_cancel:-Cancel}"}${NL}if class of dialogAnswer is boolean then${NL}error number -128${NL}end if${NL}if (count of dialogAnswer) is greater than 1 then${NL}set dialogAnswers to ""${NL}repeat with choice from 1 to count of dialogAnswer${NL}set theCurrentItem to item choice of dialogAnswer${NL}set dialogAnswers to dialogAnswers & theCurrentItem & "\n"${NL}end repeat${NL}else${NL}return dialogAnswer as string${NL}end if${NL}end timeout${NL}${endTell_AS}
EOF
;;"file"*|"folder")[ "${option_H_flag:=0}" -eq 1 ] && local withInvisibles_AS="with invisibles";if [ -d "${defaultOption}" ]; then local folderPath="${defaultOption}";elif [ "${defaultOption:0:1}" = '~' ]; then local homeFolder="$(dscl . -read /Users/$consoleUser NFSHomeDirectory | awk -F ": " '{print $NF}')"; local folderPath="${homeFolder}${defaultOption:1}";elif [ -n "${ZSH_VERSION}" ]; then local folderPath="$(dirname "${ZSH_ARGZERO:=${${funcfiletrace[-1]}[(ws/:/)1]}}")";elif [ -e "${0}" ]; then local folderPath="$(dirname "$0")";else local folderPath="$(pwd)";fi;case "${uiType}" in "filename")if [ -n "${preFillString}" ]; then local defaultNameString="default name \"$preFillString\"";fi;
read -r -d '' APPLESCRIPT <<-EOF
${beep_AS}${NL}get POSIX path of (choose file name ${defaultNameString} ${withPrompt_AS} default location POSIX file "$folderPath")
EOF
;;"file"|"folder")if [ -n "${preFillString}" ]; then local choice;local fileTypeList;IFS=,;for choice in $preFillString; do [ -z "$fileTypeList" ] && fileTypeList=\"$choice\" || fileTypeList+=,\ \"$choice\";done;IFS=$' \n\t';local ofType_AS="of type {$fileTypeList}";fi;
read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set dialogAnswer to choose ${uiType} ${withInvisibles_AS} ${withPrompt_AS} ${ofType_AS} ${withMultiple_AS} default location POSIX file "${folderPath}" ${showingPackage_AS}${NL}if class of dialogAnswer is list then${NL}set dialogAnswers to ""${NL}repeat with thisAlias from 1 to count of dialogAnswer${NL}set dialogAnswers to dialogAnswers & POSIX path of item thisAlias of dialogAnswer & "\n"${NL}end repeat${NL}else if class of dialogAnswer is alias then${NL}set dialogAnswer to POSIX path of dialogAnswer${NL}end if${NL}end timeout${NL}${endTell_AS}
EOF
;;esac;;"application"*)read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set dialogAnswer to choose application ${title_AS} ${withPrompt_AS} ${withMultiple_AS} as alias${NL}if class of dialogAnswer is list then${NL}set dialogAnswers to ""${NL}repeat with thisAlias from 1 to count of dialogAnswer${NL}set dialogAnswers to dialogAnswers & POSIX path of item thisAlias of dialogAnswer & "\n"${NL}end repeat${NL}else if class of dialogAnswer is alias then${NL}set dialogAnswer to POSIX path of dialogAnswer${NL}end if${NL}end timeout${NL}${endTell_AS}
EOF
;;"color")if [ -n "${preFillString}" ] ; then local R="$(cut -d, -f1 <<< "${preFillString}")";local G="$(cut -d, -f2 <<< "${preFillString}")";local B="$(cut -d, -f3 <<< "${preFillString}")";if [ "${R}" -ge 0 -a "${R}" -le 65535 -a "${G}" -ge 0 -a "${G}" -le 65535 -a "${B}" -ge 0 -a "${B}" -le 65535 ]; then defaultColor_AS="default color {${preFillString}}";fi;elif [ -n "${defaultColorRGB}" ]; then defaultColor_AS="default color {${defaultColorRGB}}";fi;
read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set theColor to choose color ${defaultColor_AS}${NL}end timeout${NL}${endTell_AS}
EOF
;;"url")if [ -n "${serviceArgument}" ]; then case "${serviceArgument}" in "file") local servicename_AS="File servers";;"web") local servicename_AS="Web servers";;"ftp") local servicename_AS="FTP Servers";;"media") local servicename_AS="Media servers";;"telnet") local servicename_AS="Telnet hosts";;"news") local servicename_AS="News servers";;"remote") local servicename_AS="Remote applications";;"directory") local servicename_AS="Directory services";;esac;[ -n "${servicename_AS}" ] && showingService_AS="showing ${servicename_AS}";fi
read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}choose URL ${showingService_AS}${NL}end timeout${NL}${endTell_AS}
EOF
;;"alert"|"button"|"text"|*)case "${uiType}" in "alert")local windowType="alert";[ -n "${preFillString}" ] && local message_AS="message \"${preFillString}\"";;"button"|"text")local windowType="dialog";unset alertLevel_AS;[ -z "${titleString}" -a -n "${defaultTitle}" ] && local titleString="${defaultTitle}";[ -n "$titleString" ] && local title_AS="with title \"$titleString\"";;*)echo -e "Unknown UI Type: \"${uiType}\"\nFor usage: shui help\nFor examples: shui demo" >&2;return 1;;esac;[ -z "${nonBlockingFlag}" ] && local buttonCountLimit=3 || local buttonCountLimit=1;if [ -z "$buttonListArgs" -a -n "${nonBlockingFlag}" ]; then local buttonListArgs="OK";fi;if [ "$(grep -c $'\n' <<< "$buttonListArgs")" -ge 2 ]; then IFS=$'\n';elif [ "$(grep -c ';' <<< "$buttonListArgs")" -ge 1 ]; then IFS=$';';else IFS=,;fi;local button buttonListItems buttonCount;for button in ${buttonListArgs}; do [ -z "$button" ] && continue;button="$(sed "s/^[ ]*//;s/[ ]*$//" <<< "$button" )";[ -z "$buttonListItems" ] && buttonListItems=\"${button}\" || buttonListItems+=,\ \"${button}\";let $((buttonCount++));[ "${buttonCount:=1}" -ge "${buttonCountLimit}" ] && break;done;IFS=$' \n\t';[ -n "${buttonListItems}" ] && buttons_AS="buttons {${buttonListItems}}";if [ -n "${defaultOption}" -a "${defaultOption}" = "$(bc 2>/dev/null <<< "${defaultOption}")" ]; then if [ "${defaultOption}" -ge 1 -a "${defaultOption}" -le "${buttonCount}" ]; then local defaultButton_AS="default button ${defaultOption}"; fi;elif [ -n "${defaultOption}" -a -n "$(grep -w "${defaultOption}" <<< "${buttonListItems}")" ]; then local defaultButton_AS="default button \"${defaultOption}\"";fi;if [ -n "${cancelButton}" -a "${cancelButton}" = "$(bc 2>/dev/null <<< "${cancelButton}")" ]; then if [ "${cancelButton}" -ge 1 -a "${cancelButton}" -le "${buttonCount}" ]; then local cancelButton_AS="cancel button ${cancelButton}";fi;elif [ -n "${cancelButton}" -a -n "$(grep -w "${cancelButton}" <<< "${buttonListArgs}")" ]; then local cancelButton_AS="cancel button \"${cancelButton}\"";fi;if [ -f "${iconArgument}" -a "${uiType}" != "alert" ]; then local withIcon_AS="with icon file (POSIX file \"${iconArgument}\")";elif [ ! -f "${iconArgument}" -a "${uiType}" != "alert" ]; then case "${iconArgument}" in "stop"|"0")if [ -z "${applicationNameArg}" -o "${applicationNameArg}" = "System Events" ]; then local alertIconUnixPath="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertStopIcon.icns"; else local alertIconName="stop";fi;;"caution"|"2")if [ -z "${applicationNameArg}" -o "${applicationNameArg}" = "System Events" ]; then local alertIconUnixPath="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertCautionIcon.icns"; [ ! -f "${alertIconUnixPath}" ] && alertIconUnixPath="/System/Library/CoreServices/Problem Reporter.app/Contents/Resources/ProblemReporter.icns";else local alertIconName="caution";fi;;"note"|"1")if [ -z "${applicationNameArg}" -o "${applicationNameArg}" = "System Events" ]; then local alertIconUnixPath="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertNoteIcon.icns";else local alertIconName="note";fi;;*)if [ -f "${iconArgument}/Icon"$'\r' ]; then local tempIcon="/tmp/shui_icon-${RANDOM}.icns"; local resourceHexString="$(xattr -p com.apple.ResourceFork "${iconArgument}/Icon"$'\r')";[ -n "${resourceHexString}" ] && xxd -r -p - <<< "${resourceHexString:780}" > "${tempIcon}";if [ -s "${tempIcon}" ] && [ -z "$(grep ": data" <<< "$(file "${tempIcon}")")" ]; then local alertIconUnixPath="${tempIcon}"; fi;fi;if [ -f "${iconArgument}"/Contents/Info.plist -a -z "${alertIconUnixPath}" ]; then local bundleIconFileName="$(defaults read "${iconArgument}"/Contents/Info.plist CFBundleIconFile 2>/dev/null)"; [ -z "${bundleIconFileName}" ] && bundleIconFileName="$(defaults read "${iconArgument}"/Contents/Info.plist CFBundleIconName 2>/dev/null)"; [ "${bundleIconFileName}" = "${bundleIconFileName/.icns/}" ] && bundleIconFileName="${bundleIconFileName}".icns;local bundleIconPath="${iconArgument}"/Contents/Resources/"${bundleIconFileName}";if [ -f "${bundleIconPath}" ]; then local alertIconUnixPath="${bundleIconPath}";else local alertIconUnixPath="${defaultIcon}";fi;fi;;esac;if [ -f "${alertIconUnixPath}" ]; then local withIcon_AS="with icon file (POSIX file \"${alertIconUnixPath}\")";elif [ -n "${alertIconName}" ]; then local withIcon_AS="with icon ${alertIconName}";fi;fi;[ "${option_H_flag:=0}" -eq 1 ] && local withHiddenAnswer_AS="with hidden answer";if [ -n "${nonBlockingFlag}" -a "${uiType}" = "text" ]; then unset nonBlockingFlag;fi;if [ "${uiType}" = "text" ]; then local defaultAnswer_AS="default answer \"$preFillString\"";fi;if [ -z "${iconArgument}" -a -n "${defaultIcon}" ]; then local iconArgument="${defaultIcon}";fi;if [ "${iconArgument:0:1}" = '~' ]; then local homeFolder="$(dscl . -read /Users/$consoleUser NFSHomeDirectory | awk -F ": " '{print $NF}')"; local iconArgument="${homeFolder}${iconArgument:1}";fi;[ -n "${giveupSeconds}" ] && local giveup_AS="giving up after \"$giveupSeconds\"";if [ -n "${nonBlockingFlag}" ]; then 
read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set dialogAnswer to display ${windowType} "${promptString}" ${alertLevel_AS} ${message_AS} ${title_AS} ${withIcon_AS} ${buttons_AS} ${giveup_AS} ${defaultButton_AS} ${cancelButton_AS}${NL}end timeout${NL}${endTell_AS}
EOF
else read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set dialogAnswer to display ${windowType} "${promptString}" ${alertLevel_AS} ${message_AS} ${defaultAnswer_AS} ${withHiddenAnswer_AS} ${title_AS} ${withIcon_AS} ${buttons_AS} ${giveup_AS} ${defaultButton_AS} ${cancelButton_AS}${NL}end timeout${NL}${endTell_AS}
EOF
fi;;esac;if [ -n "$outputFlag" ]; then local a invocationQuoted; if [ -n "$ZSH_VERSION" ]; then for ((a=1; a <= ${#argv[@]}; a++ )); do [ "${argv[$a]:0:1}" = '-' ] && invocationQuoted+="${argv[$a]} " || invocationQuoted+="'${argv[$a]}' "; done; elif [ -n "$BASH_VERSION" ]; then if [ "${BASH_ARGC:-0}" -eq 1 ]; then local invocationQuoted="$@"; else for ((a=$((${BASH_ARGC:-0}-2)); a >= 0; a-- )); do [ "${BASH_ARGV[$a]:0:1}" = '-' ] && invocationQuoted+="${BASH_ARGV[$a]} " || invocationQuoted+="'${BASH_ARGV[$a]}' ";done;fi;fi;echo -e "Arguments:\n${uiType} ${invocationQuoted}\n" >&2;fi;[ -n "$outputFlag" ] && (echo "Applescript:" >&2; cat <<< "$APPLESCRIPT" | tr -s ' ' | sed '/^$/d' >&2; echo >&2);if [ -n "${killAllProcs}" ]; then local sysEventsPID osascriptPID;for sysEventsPID in $(pgrep System\ Events); do eval ${asuserPrefix} kill -9 "${sysEventsPID}";done;for osascriptPID in $(pgrep osascript); do eval ${asuserPrefix} kill -9 "${osascriptPID}";done;fi;if [ -n "${killChildProcsOnly}" ]; then local sysEventsPID osascriptPID childPID; local childPIDs="$(pgrep -P $$)"; for childPID in $(pgrep -P $$); do local grandChildPID="$(pgrep -P $childPID)";local grandChildPIDString="$(ps ${grandChildPID} | tail -n +2)";if grep -q "osascript$" <<< "${grandChildPIDString}"; then if grep -q "sudo$" <<< "$(pgrep -laP $childPID)"; then local childPIDToKill="$(pgrep -P $grandChildPID)"; else local childPIDToKill="${grandChildPID}"; fi;fi;[ -n "${childPIDToKill}" ] && eval ${asuserPrefix} kill -9 "${childPIDToKill}";done;fi;if [ -z "${nonBlockingFlag}" ]; then local tempStdErrFile="/tmp/shuiError-${RANDOM}.txt";lastResult="$(eval ${asuserPrefix} /usr/bin/osascript 2>${tempStdErrFile} <<< "$APPLESCRIPT")";lastError="$(< "${tempStdErrFile}")";rm "${tempStdErrFile}";[ $(( $(wc -l <<< "${lastError}") )) -gt 1 ] && local lastError_escaped="$(sed -e 's/\\/\\\\/g' -e :a -e N -e '$!ba' -e 's/\n/\\n/g' <<< "${lastError}")" || local lastError_escaped="$(sed -e 's/\\/\\\\/g' <<< "${lastError}")";lastError_escaped="$(sed -e $'s/\r/\\\\r/g' -e $'s/\t/\\\\t/g' -e $'s/\b/\\\\b/g' -e $'s/\f/\\\\f/g' -e $'s/\v/\\\\v/g' -e $'s/\'/\\\\\'/g' <<< "${lastError_escaped}")";else { ( eval ${asuserPrefix} /usr/bin/osascript &>/dev/null <<< "$APPLESCRIPT"; [ -e "${tempIcon}" ] && rm -f "${tempIcon}" ) & };local childPID=$!;sleep .2; local grandChildPID="$(pgrep -P ${childPID})";if [ -n "${grandChildPID}" -a -z "${tellApp_AS}" ]; then if grep -q "sudo$" <<< "$(pgrep -laP $childPID)"; then lastPID="$(pgrep -P $grandChildPID)"; else lastPID="${grandChildPID}"; fi;fi;fi;if [ -n "${lastResult}" ]; then [ $(( $(wc -l <<< "${lastResult}") )) -gt 1 ] && local lastResult_escaped="$(sed -e 's/\\/\\\\/g' -e :a -e N -e '$!ba' -e 's/\n/\\n/g' <<< "${lastResult}")" || local lastResult_escaped="$(sed -e 's/\\/\\\\/g' <<< "${lastResult}")";lastResult_escaped="$(sed -e $'s/\r/\\\\r/g' -e $'s/\t/\\\\t/g' -e $'s/\b/\\\\b/g' -e $'s/\f/\\\\f/g' -e $'s/\v/\\\\v/g' -e $'s/\'/\\\\\'/g' <<< "${lastResult_escaped}")";local lastResultFragment_escaped="${lastResult_escaped}";case "${uiType}" in "alert"|"button"|"text") if [ -n "${giveup_AS}" ]; then if grep -q "gave up:true$" <<< "${lastResultFragment_escaped}"; then lastGaveUp="true";else lastGaveUp="false";fi;lastResultFragment_escaped=$(sed -e 's/, gave up:true$//' -e 's/, gave up:false$//' <<< "${lastResultFragment_escaped}");fi;local lastButton_escaped="$(awk -F '^button returned:|, text returned:' '{print $2}' <<< "${lastResultFragment_escaped}")";lastCancel="false";eval lastButton=\$\'"${lastButton_escaped}"\';lastResultFragment_escaped="$(sed -e 's/^button returned:'"${lastButton_escaped//\\/\\\\}"'//' <<< "${lastResultFragment_escaped}")";if grep -q "^, text returned:" <<< "${lastResultFragment_escaped}"; then local lastText_escaped="$(sed -e 's/^, text returned://' <<< "${lastResultFragment_escaped}")";eval lastText=\$\'"${lastText_escaped}"\';fi;;"file"*|"folder"|"application"|"color"|"url"|*) lastChoice="${lastResult}";[ $(( $(wc -l <<< "${lastChoice}") )) -gt 1 ] && local lastChoice_escaped="$(sed -e 's/\\/\\\\/g' -e :a -e N -e '$!ba' -e 's/\n/\\n/g' <<< "${lastChoice}")" || local lastChoice_escaped="$(sed -e 's/\\/\\\\/g' <<< "${lastChoice}")";lastChoice_escaped="$(sed -e $'s/\r/\\\\r/g' -e $'s/\t/\\\\t/g' -e $'s/\b/\\\\b/g' -e $'s/\f/\\\\f/g' -e $'s/\v/\\\\v/g' -e $'s/\'/\\\\\'/g' <<< "${lastChoice_escaped}")";lastCancel="false";;esac;elif [ "${uiType}" = "url" -a -z "${lastError}" ]; then lastCancel="false";elif [ -z "${nonBlockingFlag}" ]; then lastCancel="true";fi;[ -e "${tempIcon}" -a -z "${nonBlockingFlag}" ] && rm -f "${tempIcon}";if [ -n "${outputFlag}" -o -n "${variableFlagPlus}" ]; then printf "Result:\n%s\n\n" "${lastResult}" >&2;printf "Error:\n%s\n\n" "${lastError}" >&2;fi;if [ -n "${variableFlag}" ]; then /bin/echo "lastButton=\$'${lastButton_escaped}'";/bin/echo "lastText=\$'${lastText_escaped}'";/bin/echo "lastChoice=\$'${lastChoice_escaped}'";/bin/echo "lastGaveUp='${lastGaveUp}'";/bin/echo "lastCancel='${lastCancel}'";/bin/echo "lastResult=\$'${lastResult_escaped}'";/bin/echo "lastError=\$'${lastError_escaped}'";/bin/echo "lastPID='${lastPID}'";fi;[ -n "${lastError}" -o "${lastCancel}" = "true" ] && return 1
}
## END SHUI FUNCTION ##

##########################################################################################
# TEST FUNCTIONS #
##########################################################################################

function button_demo {
shui button -p "Specify icons by specific file, the .app bundle or with keywords \"stop\", \"caution\", and \"note\"\nDefault buttons can be specified by name or number..." -b "OK,Cool,Cancel" -d "Cool" -t "Your Title Here" -i "/System/Library/CoreServices/Finder.app" -V

#lastCancel is set to true/false every time shui is invoked, also for single buttons with comma use a trailing semi-colon
[ "${lastCancel}" = "true" ] && shui button -p "You clicked Cancel!" -i "stop" -t "Cancel Clicked" -b "Yes, I did;" -d1

shui button -p "You can specify a cancel button by name (Skip) or number (3)\nCancel will return NO button results when clicked\nYou can also use the \$lastCancel variable\n\nClick Skip for Cancel detection" -b "This,That,Skip" -d 1 -c 3 -i "caution" -V

#lastCancel is set to true/false every time shui is invoked, also for single buttons with comma use a trailing semi-colon
[ "${lastCancel}" = "true" ] && shui button -p "You clicked Cancel!" -i "stop" -t "Cancel Clicked" -b "Yes, I did;" -d1

shui button -p "Specifying a give up time (-g) makes a nice pop-up that alerts but moves on after a while..." -g "10" -b "OK" -d 1 -t "Title" -i "/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/Clock.icns" -V

multiLineText="You can put lots of text in a window

• For a list of things to tell a user
• Please Make sure you realize...
	° This
	° That
	° The other

\"Cool\", right?"

#you can use mutliline variables to neatly compose your invocation
shui button -p "${multiLineText}" -b "Yes,No,Maybe" -t "Greetings" -i "caution" -d "Yes" -V
}

#unencode emoji work just fine also (just not on Jamf)
function 1emoji_demo {
multiLineText="shui works with Unicode™ and Emoji 

\0342\0234\0205 Dialogs, buttons, pre-fills, etc...

Note: Multibyte emojis in Jamf Pro scripts MUST be encoded, you may reliably use these encoding schemes

UTF-8 \\\\xhh Hex encoding:
\\\\xf0\\\\x9f\\\\x98\\\\x8e = \xf0\x9f\x98\x8e

UTF-8 \\\\0nnn Octal encoding:
\\\\0360\\\\0237\\\\0230\\\\0216 = \0360\0237\0230\0216

Unicode characters can be encoded using jpt the JSON Power Tool: https://github.com/brunerd/jpt
"

#you can use mutliline variables to neatly compose your invocation
shui button -p "${multiLineText}" -b "\0360\0237\0237\0242 Yes,\xf0\x9f\x9b\x91 No,\0342\0232\0240\0357\0270\0217Maybe" -t "\xf0\x9f\x93\xa3 Greetings \xf0\x9f\x94\x8a" -i "caution" -d "\xf0\x9f\x9f\xa2 Yes" -V
}

function text_demo {
#single line, pre-filled answers are returned on give-up
shui text -p "Question for you, 15 seconds though!\nNote: It will return the pre-fill after timeout, lastGaveUp will be true" -P "Pre-Filled Answer" -t "Title" -i "/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/Actions.icns" -b "Send,Save,Trash" -d 1 -c 3 -g 15 -V

#passwords benefit from being hidden
shui text -p "Hidden Input with Pre-Filled answer...\nSpecifying an app brings focus and icon keywords will badge the app icon" -h -P "secr3t" -t "Password Prompt" -i "stop" -b "Submit,Cancel" -d 1 -V -a Terminal

#multi-line windows are possible if you padd the pre-fill with newlines ending with a space or any other character(s), "\n" are evaluated as LF or you can use $'\n'
#FYI: text entry window will NOT have scroll bars
shui text -p "Please tell us what you REALLY think:" -P "\n\n\n " -t "Multi-Line Text Responses"  -b "Cancel,Comment" -d 2 -V

#buttons with commas are possible and automatically recognized when a newline is present
shui text -p "You can put commas in buttons if you delimit with newlines\n\nLack of default button ensures accidentally hitting Return does not move on..." -i "note" -t "Title" -b "OK, Boomer"$'\n'"Cancel" -V
}

function list_demo {
#first button name is for "OK" button, the second if for the cancel button
shui list -p "Choose One, custom buttons" -l "This,That,Other" -t "Title"  -b 'Remove,Skip' -P "Other" -V

#while the list choice demiliters default to comma, you can specify a custom delimiter like LF if you need to used commas
local bunchaChoices="This has commas, neato!
This one too, wow"
shui list -p "Items have commas by using custom delimiter, buttons can include commas if newlines used" -l "$bunchaChoices" -t "Title" -b 'Remove, Please'$'\n''Ignore' -D $'\n' -P "This one too, wow" -V

#while the list choice demiliters default to comma, you can specify a custom delimiter like space if you want
local bunchaChoices="true false truthy"
shui list -p "Choose One or none from space delimited list with custom delimiter" -l "$bunchaChoices" -t "Custom Title" -b 'Pick,Pass' -D " " -e -V

#a single button name will be used for the "OK" button
shui list -p "Choose One or More (Custom Buttons) with Shift or Command clicking" -m -l "Eenie,Meanie,Minie,Moe" -t "Title" -b 'Choose' -P "Eenie,Moe" -V

#buttons default to "OK, Cancel"
shui list -p "Choose One or More with Shift or Command clicking" -m -l "This,That,Other" -t "Title" -V

#allowing commas in a list mean changing the delimiter to $'\n' from ,
local bunchaChoices="This has commas, neato!
This one too, wow
I will forget Applescript after using this"
shui list -p "Choose One or More (Custom buttons) with Shift or Command clicking" -m -l "$bunchaChoices" -t "Title" -b 'Yep,Nope' -D $'\n' -V
}

function file_demo {
#pick a file or folder, defaults to where the script is running
shui file -p "Pick a file inside an app or package bundle" -d '/System/Library/CoreServices' -s -V

#pick a file or folder, defaults to where the script is running
shui file -p "Pick a hidden file..." -h -d '~' -V

#pick a file or folder, defaults to where the script is running
shui file  -p "Pick multiple files using Shift and Command keys..." -m -V

#specify allowed mixed UTI file extensions (-f) and a default folder to look with (-d)
shui file -p "Pick a public.image or txt file only" -m -P 'public.image,txt' -d '~/Pictures' -V

#specify an allowed file extension (-f) and a folder to look with (-t)
shui file -p "Pick a .log or .out files only" -m -P 'log,out' -d "/var/log" -V
}

function folder_demo {
#pick multiple folders, will resolve ~ relative paths for the console user
shui folder -p "Pick some folders from your Desktop..." -m -d '~/Desktop' -V

#specify an a default directory to look in with -d and inside
shui folder -p "Pick a folder inside an Application" -s -d "/Applications" -V

#pick a file or folder, defaults to where the script is running
shui folder -p "Pick a folder, origin of current script if not specified..." -h -V

#specify a default directory to look in with -d 
shui folder -p "Pick folders starting at root" -m -d "/" -V
}

function alert_demo {
shui alert -p "Alert Prompt" -P "Alerts do not have titles, the prompt text will be bolder though\nThe icon will be the application specified with -a or a folder if no application is specified\nThis is an info/warning level alert (default)..." -b "OK" -d 1 -V

shui alert -p "Bold Alert Prompt" -P "The critical alert level overlays the application icon with a caution sign" -b "This,That,Cancel" -d 1 -c 3 -L "critical" -V

shui alert -p "Specify an application with the -a option" -P "The icon is jazzed up but this will inhibit any other action in the app until dismissed and may require additional PPPC permissions" -b "OK," -d 1 -a "Terminal" -L "critical" -V
}

function znonBlockingButton-System_Events_demo {
#timeout
shui button -a "System Events" -p "Non-blocking window (-n) with give up of 10 seconds, the script proceeds (not blocked) and no values are returned\n\nNote: Give up time will affect subsequent System Events windows if this is still open...\n" -b "Wait for it..." -g 10 -i "caution" -n -V
echo "Script proceeding, sleeping 5 seconds..."
sleep 5
shui button -a "System Events" -p "Like this one...\nThis one will get the time out from the previous window, so only specify -a \"System events\" if you want to be able to kill the non-blocking window later..." -b "Uh oh" -g 10 -i "caution" -V
echo "Script proceeding, sleeping 5 seconds..."
sleep 5
shui button -a "System Events" -p "This window is now covering a window that is stuck... and this has a give up of 1 hour BUT it can be killed along with all other System Events based windows with -X\n\nWait for it... (10 seconds)" -b "Wait for it..." -g 3600 -i "stop" -d 1 -n -V
echo "Script proceeding, sleeping 10 seconds..."
sleep 10
shui button -p 'BOOM!\nAnonymous windows and those with System Events as the application (-a) can be cleared with -X\n' -X -b "OK" -V -N -i "/System/Library/CoreServices/Finder.app"
echo "Script proceeding, sleeping 5 seconds..."
sleep 5
shui alert -p "Alerts can be non-Blocking too" -P "If you specify any OTHER app besides System Events with -a they CANNOT be killed with -X or -x" -N  -L "critical" -B 1 -X
echo "Script proceeding, sleeping 7 seconds..."
sleep 7
}

function znonBlockingButton-Anonymous_demo {
#timeout
shui button -p "Non-blocking windows (-n) WITHOUT a specified app (-a) will NOT block each other but they WILL still stack up on top of each other.\n\nClick OK to spawn 3 pop-ups\n\nNote: You can't get results back from non-blocking buttons and alerts" -b "OK" -i "/System/Library/CoreServices/Finder.app" -V
shui button -n -p "One non-blocking window..." -b "OK" -i "stop" -V
sleep 2
shui button -n -p "Two non-blocking windows..." -b "OK" -i "caution" -V
sleep 2
shui button -n -p "Three non-blocking windows!!!" -b "OK" -i "note" -V
sleep 2
shui button -p "Look under this window there are 3 other windows.Click Close All to close these windows with (-x) which ONLY closes osascript child processes in this script" -b "Close All" -i "stop" -V
shui button -x -p "Boom. That killed all the windows.\n\n-X kills ALL osascript and System Event processes but -x is much more targetted and requires shui to be embedded for best results\n\nlastPID is a new global var for your script to track non-Blocking PIDs" -b "OK" -i "/System/Library/CoreServices/Finder.app" -V
}


function application_demo {
#timeout
shui application -p "Pick one application..." -t "App Picker" -V

#timeout
shui application -p "Pick one or more applications using the Shift and Command keys..." -m -t "Multi-App Picker" -V
}

function url_demo {
#URL defaults to "file" servers if no service specified (-S)
shui url -V

#URL with service specified
shui url -S "web" -V
}

function color_demo {
shui color -V

shui color -P "12000,30000,45000" -V
}

function filename_demo {
#pick a file or folder, defaults to where the script is running
shui filename -p "Pick a file name to Save As..." -d '~/Desktop' -P "PrePopulated_Name-$RANDOM.txt" -V
}

function Q_and_A_demo {
shui text -p 'Hi! What is your name?' -d "OK" -t "shui demo" -V
local myName="${lastText:-Unknown}"

shui button -p "Good to meet you ${myName}, which do you prefer?" -b "Day,Night,Both" -V
local timeOfDayPref="${lastButton}"

shui list -p "Are any of these are your favorite fruits?" -l "Apples,Bananas,Blueberries,Kiwi Fruit,Jack Fruit,Durian,Sugar Cane" -m -V -e
local myFruitsRAW="${lastChoice}"
#count the lines, ensure line is not empty as the wc -l method always return 1 or greater, otherwise it is zero
[ -n "${myFruitsRAW}" ] && local myFruitsLines="$(wc -l <<< "$(sed -e '/^$/d' <<< "$myFruitsRAW")" | sed -e 's/^[ ]*//g')" || local myFruitsRAW=0

if [ "${myFruitsLines}" -eq 0  ]; then
	s=""
	isare="is"
	myFruits="None"
elif [ "${myFruitsLines}" -eq 1  ]; then
	s=""
	isare="is"
	myFruits="${myFruitsRAW}"
else
	s="s"
	isare="are"
	myFruits="$(sed -e :a -e N -e '$!ba' -e 's/\n/, /g'<<< "${myFruitsRAW}")"
fi

shui alert -p "Here are my findings, $myName" -P "Your preference of day or night is: $timeOfDayPref
Your favorite fruit${s} ${isare}: ${myFruits}" -b "OK" -d 1
}

function testMenu {
#if this is zsh proceed (substitution style is zsh only)
if [ -n "${ZSH_NAME}" ]; then
	#http://people.apache.org/~danielsh/zsh/mhonarc-test-20180920001/workers-2018/msg00008.html
	#get path to self even for zsh 5.3 and under
	local myPath="${ZSH_ARGZERO:=${${funcfiletrace[-1]}[(ws/:/)1]}}"
#in bash this will be the script (in zsh this is the function name)
elif [ -e "${0}" ]; then
	local myPath="$0"
fi

#build our list of function names ending in "_demo"
testFunctionsList="$(grep ^function "${myPath}" | grep "_demo" | awk '{print $2}' | sort -df)"
while :; do
	#the main menu using -x to kill any background windows
	shui list -D "LF" -l "${testFunctionsList}" -b "Run,Exit" -p "Pick one or more test functions to run..." -t "shui" -m -x
	#if it's empty quit (2nd button in list is ALWAYS Cancel) otherwise invoke the function
	if [ -z "${lastChoice}" ]; then
		exit
	else
		for function in ${lastChoice}; do
			"$function"
		done
	fi
done
}

########
# MAIN #
########

case ${1} in
	"menu"|"demo")
		#make a menu of all the test functions
		testMenu
		;;
	*)
		#pass-through all arguments
		shui "$@"
		;;
esac
