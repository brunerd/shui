#!/bin/zsh
#!/bin/bash
#shui - a zsh/bash function to easily add Applescript user interaction to your script

#this script includes demostration code, use it to test syntax out or run the demo function with: "./shui demo"
#to use in your script: copy and paste ONLY the function shui {...} into your script

#this is the demo script, use it to test syntax out or run the demo function with: "./shui demo"
#to use in your script: copy and paste ONLY the function shui {...} into your script, OMIT the TEST FUNCTIONS

## BEGIN SHUI FUNCTION ##
function shui
{
: <<-EOL
shui (20210309) - a zsh/bash function to easily add Applescript user interaction to your script (https://github.com/brunerd/shui)
Copyright (c) 2020 Joel Bruner
MIT License
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
EOL
#if the silentMode or shui_silentMode flag is set to Y return
[ "${shui_silentMode}" = "Y" -o "${silentMode}" = "Y" ] && return
#[ -z "$(pgrep 'Self Service')" ] && return
#[ -n "$(pgrep 'jamfHelper')" ] && return
#defaults - set global vars shui_defaultxxxxxx or hardcode
local defaultIcon="${shui_defaultIcon}"
[ -n "${shui_defaultTitle}" ] && local defaultTitle="$(echo -e "${shui_defaultTitle}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')"
[ -n "${shui_defaultOption}" ] && local defaultOption="$(echo -e "${shui_defaultOption}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g')"
local timeoutDefault="${shui_timeoutDefault}"
local defaultApplication="${shui_defaultApplication}"
local defaultColorRGB="${shui_defaultColor:-65535,65535,65535}" #white
#end defaults
local timeoutSecondsAppleScript=${timeoutDefault:-"133200"};local consoleUserID=$(stat -f %u /dev/console);local consoleUser=$(stat -f %Su /dev/console); if [ -n "$ZSH_VERSION" ]; then set -y; elif [ -n "$BASH_VERSION" ]; then	 local array_offset="1"; unset OPTIND OPTARG; fi
local NL=$'\n';local asuserPrefix="launchctl asuser ${consoleUserID} sudo -u ${consoleUser}";unset lastButton lastText lastChoice lastGaveUp;local APPLESCRIPT
read -r -d '' helpText <<'EOT'
shui - add Applescript user interaction to your shell script (https://github.com/brunerd/shui)\n\nUsage:\nshui [<UI Type>] -p "<prompt text>" \n\nUI Types:\nalert: alert with icon of the calling appication (use -a), prompt (-p) is bold, message text (-P) is smaller, can set level (-L) to critical\napplication: presents list of Launch Services registered applicatins can specify -m for multiple\nbutton (default): button based reply, use -b to change button names (max 3), defaults to "Cancel,OK" like Applescript does\ncolor: no options, presents color picker and returns "R,G,B" with individual values (0-65535)\nfile: pick one file or multiple (-m), -d for default folder, -P to specify preferred file extensions or UTIs, -h hidden items, -s show bundle contents\nfolder: pick one file or multiple (-m), -d for default folder, -P to specify preferred file extensions, -h hidden items, -s show bundle contents\nlist: pick one or mutiple (-m) items from a list of choices, use -D for custom delimiter (comma default)\ntext: like button but with a single line text entry box, set pre-filled text with -P, hidden text with -h\nurl: returns a URL, default is file servers, use -S to set the kind of server to look for, valid value listed below\n\nRequired:\n-p "prompt text"\talert/button/file/folder/list: the text prompt presented to the user, required for all type (except color)\n\nOptions (begins with UI type(s) which apply or "all"):\n\n-a "<application>"\tall (except filename): specify the application that will present the Applescript dialog, alert will have app icon and block app\n\n-b "<button>;...;..."\tbutton: max 3 button names, comma or semi-colon delimited (if commas AND semi-colons are present, semis "win") \n\t\t\t\t\t\tif no buttons specified it defaults to the standard Applescript "Cancel,OK"\n-b "<OK>,[<Cancel>]"\tlist: max 2 button names, comma delimited, first is the OK button name, second is Cancel button name (optional)\n\n-B "n"\t\t\tall: beep n number of times\n\n-c "name/number"\tbutton: specify the cancel button by name or number\n\n-d "name/number"\tbutton: default button name or number (0 will suppress Applescript OK button default if -b not specified)\n-d "<Folder Path>"\tfile/folder: default location (Unix Path), using ~ will resolve to the console user's home folder\n\n-D "<delimiter>"\tlist: Delimiter for -l list items, can specify literal character like $'\\n' or use these two named shortcuts "LF" "IFS"\n\n-e \t\t\tlist: allow empty selection\n\n-g "seconds"\t\talert/button: give-up timeout in seconds (dismisses windows and moves on)\n\n-h\t\t\ttext: hidden text entry (dots)\n-h\t\t\tfile/folder: show hidden files in picker\n\n-i "<path>"\t\tbutton: path to icon file or application bundle (Icon^M first, then Info.plist)\n\n-l "item,item,..."\tlist: items for list, comma delimited is default unless newline is detected (change delimiter with -D)\n\n-L "<level>"\t\talert: default is ‌"informational"/"‌warning" (same), "critical" adds a caution sign over the calling app (-a) icon\n\n-m\t\t\tapplication/file/folder/list: allow multiple selections\n\n-n\t\t\talert/button: non-Blocking window, spawns to a background and moves on, response is not captured, one button maximum\n \t\t\tNote: If this is NOT the last alert window it is advisable to use a giveup (-g) value, additional dialogs will occlude previous ones (use -X to clear)\n\n-N\t\t\talert/button: same as (-n) non-blocking window except button 1 is default\n\n-o\t\t\tall: output Applescript code\n\n-P "message text"\talert: "parenthetical" message text below the bold prompt text\n-P "<R>,<G>,<B>"\tcolor: pre-chosen RGB color values 0-65536\n-P "filename"\t\tfilename: pre-filled file name (default folder set with -d)\n-P "extension,UTI,..."\tfile: "preferred" file extensions/UTIs available to choose in picker\n-P "item,item..."\tlist: pre-chosen items, default delimiter is comma unless a newline is present or can be set with -D\n-P "pre-fill text"\ttext: pre-filled text (may be hidden with -h)\n\n-S "<Service>"\t\turl: look for specific services, useful values are: "file" (default) and "web" \n\t\t\tLess useful but still valid values are: "ftp", "media", "telnet", "news", and "remote" (applications)\n\n-s\t\t\tfile/folder: show package/bundle contents (as a folder basically)\n\n-t "Title text"\t\tbutton/list/text: window title (can be hardcoded)\n\n-v\t\t\tall: output results in format suitable for initializing shell variables\n-V\t\t\tall: output results in format suitable for initializing shell variables plus Applescrtipt and raw returned "osascript" value\n\n-X\t\t\talert/button: kill any "System Events" based windows (-a specified), useful for non-Blocking without give up\n\nshui sets four GLOBAL variables within the script's running context:\n\tlastButton - value of button from button, text, and list replies\n\tlastText - Text string from text reply\n\tlastChoice - File or Folder Unix path from files/filename/folders\n\tlastGaveUp - true or false. Only used with button and text reply type if a give up value is specified\n\n
EOT
if [ -z "${1}" ]; then echo -e "No arguments given!\nFor usage: shui help\nFor examples: shui demo" 2>/dev/null; return;elif [ "${1}" = "help" ]; then echo "${helpText}" > /dev/stderr;exit;elif [ "$(cut -c1-1 <<< ${1})" = "-" ]; then local uiType="button";else local uiType=$(tr "[[:upper:]]" "[[:lower:]]" <<< "${1}");shift 1;fi;while getopts ":B:L:t:g:P:p:i:b:c:D:S:d:l:a:nehmNsovVX" option; do case "${option}" in 'a')local applicationNameArg="${OPTARG}";;'b')local buttonListArgs=$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g');;'B')local beep_AS="beep ${OPTARG}";;'c')local cancelButton=$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g');; 'd')local defaultOption=$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g');;'D')local listDelimiter="${OPTARG}";;'e')local withEmpty_AS="with empty selection allowed";;'g')local giveupSeconds="${OPTARG}";;'h')local option_H_flag="1";;'i')local iconArgument="${OPTARG}";;'L')local alertLevel_AS="as ${OPTARG}";;'l')local listItems=$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g');;'m')local withMultiple_AS="with multiple selections allowed";;'n')local nonBlockingFlag="1";;'N')local nonBlockingFlag="1";local defaultOption="1";;'o')local outputFlag="1";;'p')local promptString=$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g'); local withPrompt_AS="with prompt \"${promptString}\"";;'P')local preFillString=$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g');;'S')local serviceArgument="${OPTARG}";;'s')local showingPackage_AS="with showing package contents";;'t')local titleString=$(echo -e "${OPTARG}" | sed -e 's/\\/\\\\/g' -e 's/\"/\\\"/g');;'v')local variableFlag="1";;'V')local variableFlag="1";local outputFlag="1";local variableFlagPlus="1";;'X')local killSystemEventsFlag="1";;esac;done;if [ -z "${promptString}" -a "${uiType}" != "color" -a "${uiType}" != "url" ]; then echo "Please provide prompt text in the form of: shui text -p \"text\"" >/dev/stderr;return;fi;if [ -z "${applicationNameArg}" -a -n "${defaultApplication}" ]; then applicationNameArg="${defaultApplication}"; fi; if [ -z "${iconArgument}" -a -e "${defaultIcon}" ]; then iconArgument="${defaultIcon}"; fi;if [ "${uiType}" = "color" -a -z "$applicationNameArg" ]; then applicationNameArg="System Events"; fi;if [ -n "${applicationNameArg}" ]; then tellApp_AS="tell application \"${applicationNameArg}\"";endTell_AS="end tell";fi;case "${uiType}" in "list") local listItems_AS preChosenList_AS listArray preChosenArray button_OK button_cancel;if [ -z "${listItems}" ]; then echo "No data for list!"; return;fi;if [ -n "${buttonListArgs}" ]; then if [ "$(grep -c $'\n' <<< "${buttonListArgs}")" -ge 2 ]; then local button_OK=$(sed -n 1p <<< "${buttonListArgs}");local button_cancel=$(sed -n 2p <<< "${buttonListArgs}");else [ "$(grep -c $';' <<< "${buttonListArgs}")" -ge 1 ] && local buttonDelimiter=';' || local buttonDelimiter=',';local button_OK=$(cut -d "${buttonDelimiter}" -f1 <<< "${buttonListArgs}");local button_cancel=$(cut -d "${buttonDelimiter}" -f2 <<< "${buttonListArgs}");[ "${button_cancel}" = "${button_OK}" ] && button_cancel="";fi;fi;if [ "${listDelimiter}" = "IFS" ]; then IFS=$' \n\t' listArray=( ${listItems} ); elif [ "${listDelimiter}" = "LF" ]; then IFS=$'\n' listArray=( ${listItems} ); elif [ -n "${listDelimiter}" ]; then IFS=${listDelimiter} listArray=( ${listItems} );else if [ "$(grep -c $'\n' <<< "${listItems}")" -ge 2 ]; then IFS=$'\n' listArray=( ${listItems} );else IFS=, listArray=( ${listItems} );fi;fi;for (( j=$(( 1 - ${array_offset:-0} )); j <= $(( ${#listArray[@]} - ${array_offset:-0} )); j++ )); do [ -z "$listItems_AS" ] && listItems_AS+="\"${listArray[$j]}\"" || listItems_AS+=", \"${listArray[$j]}\"";done;if [ -n "$preFillString" ]; then if [ "${listDelimiter}" = "IFS" ]; then IFS=$' \n\t' preChosenArray=( ${preFillString} );elif [ "${listDelimiter}" = "LF" ]; then IFS=$'\n' preChosenArray=( ${preFillString} ); elif [ -n "${listDelimiter}" ]; then IFS=${listDelimiter} preChosenArray=( ${preFillString} ); else if [ "$(grep -c $'\n' <<< "${preFillString}")" -ge 2 ]; then IFS=$'\n' preChosenArray=( ${preFillString} );else IFS=, preChosenArray=( ${preFillString} );fi;fi;for (( j=$(( 1 - ${array_offset:-0} )); j <= $(( ${#preChosenArray[@]} - ${array_offset:-0} )); j++ )); do [ -z "${preChosenList_AS}" ] && preChosenList_AS+="\"${preChosenArray[$j]}\"" || preChosenList_AS+=", \"${preChosenArray[$j]}\"";[ -z "${withMultiple_AS}" ] && break;done;local defaultItems_AS="default items {${preChosenList_AS}}";fi
read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set dialogAnswer to choose from list {${listItems_AS}} ${withMultiple_AS} ${title_AS} ${withPrompt_AS} ${defaultItems_AS} ${withEmpty_AS} OK button name {"${button_OK:-OK}"} cancel button name {"${button_cancel:-Cancel}"}${NL}if class of dialogAnswer is boolean${NL}return ""${NL}end if${NL}if (count of dialogAnswer) is greater than 1 then${NL}set dialogAnswers to ""${NL}repeat with choice from 1 to count of dialogAnswer${NL}set theCurrentItem to item choice of dialogAnswer${NL}set dialogAnswers to dialogAnswers & theCurrentItem & "\n"${NL}end repeat${NL}else${NL}return dialogAnswer as string${NL}end if${NL}end timeout${NL}${endTell_AS}
EOF
;;"file"*|"folder")[ "${option_H_flag:=0}" -eq 1 ] && local withInvisibles_AS="with invisibles";if [ -d "${defaultOption}" ]; then local folderPath="${defaultOption}";elif [ "${defaultOption:0:1}" = '~' ]; then local homeFolder=$(dscl . -read /Users/$consoleUser NFSHomeDirectory | awk -F ": " '{print $NF}'); local folderPath="${homeFolder}${defaultOption:1}"; elif [ -e "${ZSH_ARGZERO}" ]; then local folderPath="$(dirname "${ZSH_ARGZERO}")"; elif [ -e "${0}" ]; then local folderPath="$(dirname "$0")";else local folderPath="$(pwd)";fi;case "${uiType}" in "filename")if [ -n "${preFillString}" ]; then local defaultNameString="default name \"$preFillString\"";fi;
read -r -d '' APPLESCRIPT <<-EOF
${beep_AS}${NL}get POSIX path of (choose file name ${defaultNameString} ${withPrompt_AS} default location POSIX file "$folderPath")
EOF
;;"file"|"folder")if [ -n "${preFillString}" ]; then local choice;local fileTypeList;IFS=,;for choice in $preFillString; do [ -z "$fileTypeList" ] && fileTypeList=\"$choice\" || fileTypeList+=,\ \"$choice\";done;IFS=$' \n\t';local ofType_AS="of type {$fileTypeList}";fi;
read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set dialogAnswer to choose ${uiType} ${withInvisibles_AS} ${withPrompt_AS} ${ofType_AS} ${withMultiple_AS} default location POSIX file "${folderPath}" ${showingPackage_AS}${NL}if class of dialogAnswer is list then${NL}set dialogAnswers to ""${NL}repeat with thisAlias from 1 to count of dialogAnswer${NL}set dialogAnswers to dialogAnswers & POSIX path of item thisAlias of dialogAnswer & "\n"${NL}end repeat${NL}else if class of dialogAnswer is alias then${NL}set dialogAnswer to POSIX path of dialogAnswer${NL}end if${NL}end timeout${NL}${endTell_AS}
EOF
;;esac;;"application"*)read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set dialogAnswer to choose application ${title_AS} ${withPrompt_AS} ${withMultiple_AS} as alias${NL}if class of dialogAnswer is list then${NL}set dialogAnswers to ""${NL}repeat with thisAlias from 1 to count of dialogAnswer${NL}set dialogAnswers to dialogAnswers & POSIX path of item thisAlias of dialogAnswer & "\n"${NL}end repeat${NL}else if class of dialogAnswer is alias then${NL}set dialogAnswer to POSIX path of dialogAnswer${NL}end if${NL}end timeout${NL}${endTell_AS}
EOF
;;"color")if [ -n "${preFillString}" ] ; then local R=$(cut -d, -f1 <<< "${preFillString}");local G=$(cut -d, -f2 <<< "${preFillString}");local B=$(cut -d, -f3 <<< "${preFillString}");if [ "${R}" -ge 0 -a "${R}" -le 65535 -a "${G}" -ge 0 -a "${G}" -le 65535 -a "${B}" -ge 0 -a "${B}" -le 65535 ]; then defaultColor_AS="default color {${preFillString}}";fi;elif [ -n "${defaultColorRGB}" ]; then defaultColor_AS="default color {${defaultColorRGB}}";fi;
read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set theColor to choose color ${defaultColor_AS}${NL}end timeout${NL}${endTell_AS}
EOF
;;"url")if [ -n "${serviceArgument}" ]; then case "${serviceArgument}" in "file") local servicename_AS="File servers";;"web") local servicename_AS="Web servers";;"ftp") local servicename_AS="FTP Servers";;"media") local servicename_AS="Media servers";;"telnet") local servicename_AS="Telnet hosts";;"news") local servicename_AS="News servers";;"remote") local servicename_AS="Remote applications";;esac;[ -n "${servicename_AS}" ] && showingService_AS="showing ${servicename_AS}";fi
read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}choose URL ${showingService_AS}${NL}end timeout${NL}${endTell_AS}
EOF
;;"alert"|"button"|"text"|*)case "${uiType}" in "alert")windowType="alert";[ -n "${preFillString}" ] && local message_AS="message \"${preFillString}\"";;*)windowType="dialog";unset alertLevel_AS;[ -z "${titleString}" -a -n "${defaultTitle}" ] && local titleString="${defaultTitle}";[ -n "$titleString" ] && local title_AS="with title \"$titleString\"";;esac;[ -z "${nonBlockingFlag}" ] && local buttonCountLimit=3 || local buttonCountLimit=1;if [ -z "${buttonListArgs}" -a -z "${nonBlockingFlag}" ]; then local buttonListArgs="Cancel,OK";[ -z "${defaultOption}" ] && defaultOption=1;elif [ -z "$buttonListArgs" -a -n "${nonBlockingFlag}" ]; then local buttonListArgs="OK";fi;if [ "$(grep -c $'\n' <<< "$buttonListArgs")" -ge 2 ]; then IFS=$'\n';elif [ "$(grep -c ';' <<< "$buttonListArgs")" -ge 1 ]; then IFS=$';';else IFS=,;fi;local button buttonListItems buttonCount;for button in ${buttonListArgs}; do [ -z "$button" ] && continue;button=$(sed "s/^[ ]*//;s/[ ]*$//" <<< "$button" );[ -z "$buttonListItems" ] && buttonListItems=\"${button}\" || buttonListItems+=,\ \"${button}\";let $((buttonCount++));[ "${buttonCount:=1}" -ge "${buttonCountLimit}" ] && break;done;IFS=$' \n\t';[ -n "${buttonListItems}" ] && buttons_AS="buttons {${buttonListItems}}";if [ -n "${defaultOption}" -a "${defaultOption}" = "$(bc 2>/dev/null <<< "${defaultOption}")" ]; then if [ "${defaultOption}" -ge 1 -a "${defaultOption}" -le "${buttonCount}" ]; then local defaultButton_AS="default button ${defaultOption}"; fi;elif [ -n "$defaultOption" -a -n "$(grep -w "${defaultOption}" <<< "${buttonListArgs//\\}")" ]; then local defaultButton_AS="default button \"${defaultOption}\"";fi;if [ -n "${cancelButton}" -a "${cancelButton}" = "$(bc 2>/dev/null <<< "${cancelButton}")" ]; then if [ "${cancelButton}" -ge 1 -a "${cancelButton}" -le "${buttonCount}" ]; then local cancelButton_AS="cancel button ${cancelButton}";fi;elif [ -n "${cancelButton}" -a -n "$(grep -w "${cancelButton}" <<< "${buttonListArgs}")" ]; then local cancelButton_AS="cancel button \"${cancelButton}\"";fi;if [ -f "${iconArgument}" -a "${uiType}" != "alert" ]; then local withIcon_AS="with icon file (POSIX file \"${iconArgument}\")";elif [ ! -f "${iconArgument}" -a "${uiType}" != "alert" ]; then case "${iconArgument}" in "stop"|"0")if [ -z "${applicationNameArg}" -o "${applicationNameArg}" = "System Events" ]; then local alertIconUnixPath="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertStopIcon.icns"; else local alertIconName="stop";fi;;"caution"|"2")if [ -z "${applicationNameArg}" -o "${applicationNameArg}" = "System Events" ]; then local alertIconUnixPath=$(find "/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/" -name 'AlertCaution*Icon.icns' | sort -r | head -n 1);else local alertIconName="caution";fi;;"note"|"1")if [ -z "${applicationNameArg}" -o "${applicationNameArg}" = "System Events" ]; then local alertIconUnixPath="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertNoteIcon.icns";else local alertIconName="note";fi;;*) 
if [ -f "${iconArgument}/Icon"$'\r' ]; then local tempIcon="/tmp/shui_icon-${RANDOM}.icns"; local resourceHexString=$(xattr -p com.apple.ResourceFork "${iconArgument}/Icon"$'\r');xxd -r -p - <<< "${resourceHexString:780}" > "${tempIcon}";[ -z "$(grep ": data" <<< "$(file "${tempIcon}")")" ] && alertIconUnixPath="${tempIcon}"; fi;if [ -f "${iconArgument}"/Contents/Info.plist -a -z "${alertIconUnixPath}" ]; then local bundleIconFileName=$(defaults read "${iconArgument}"/Contents/Info.plist CFBundleIconFile 2>/dev/null); [ -z "${bundleIconFileName}" ] && bundleIconFileName=$(defaults read "${iconArgument}"/Contents/Info.plist CFBundleIconName 2>/dev/null); [ "${bundleIconFileName}" = "${bundleIconFileName/.icns/}" ] && bundleIconFileName="${bundleIconFileName}".icns;local bundleIconPath="${iconArgument}"/Contents/Resources/"${bundleIconFileName}";if [ -f "${bundleIconPath}" ]; then local alertIconUnixPath="${bundleIconPath}";else local alertIconUnixPath="${defaultIcon}";fi;fi;;esac;if [ -f "${alertIconUnixPath}" ]; then local withIcon_AS="with icon file (POSIX file \"${alertIconUnixPath}\")";elif [ -n "${alertIconName}" ]; then local withIcon_AS="with icon ${alertIconName}";fi;fi;[ "${option_H_flag:=0}" -eq 1 ] && local withHiddenAnswer_AS="with hidden answer";if [ -n "${nonBlockingFlag}" -a "${uiType}" = "text" ]; then unset nonBlockingFlag;fi;if [ "${uiType}" = "text" ]; then local defaultAnswer_AS="default answer \"$preFillString\"";fi;if [ -z "${iconArgument}" -a -n "${defaultIcon}" ]; then local iconArgument="${defaultIcon}";fi;if [ "${iconArgument:0:1}" = '~' ]; then local homeFolder=$(dscl . -read /Users/$consoleUser NFSHomeDirectory | awk -F ": " '{print $NF}'); local iconArgument="${homeFolder}${iconArgument:1}";fi;[ -n "${giveupSeconds}" ] && local giveup_AS="giving up after \"$giveupSeconds\"";if [ -n "${nonBlockingFlag}" ]; then 
read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set dialogAnswer to display ${windowType} "${promptString}" ${alertLevel_AS} ${message_AS} ${title_AS} ${withIcon_AS} ${buttons_AS} ${giveup_AS} ${defaultButton_AS} ${cancelButton_AS}${NL}end timeout${NL}${endTell_AS}
EOF
else read -r -d '' APPLESCRIPT <<-EOF
${tellApp_AS}${NL}activate${NL}${beep_AS}${NL}with timeout of $timeoutSecondsAppleScript seconds${NL}set dialogAnswer to display ${windowType} "${promptString}" ${alertLevel_AS} ${message_AS} ${defaultAnswer_AS} ${withHiddenAnswer_AS} ${title_AS} ${withIcon_AS} ${buttons_AS} ${giveup_AS} ${defaultButton_AS} ${cancelButton_AS}${NL}end timeout${NL}${endTell_AS}
EOF
fi;;esac;if [ -n "$outputFlag" ]; then local a invocationQuoted; if [ -n "$ZSH_VERSION" ]; then for ((a=1; a <= ${#argv[@]}; a++ )); do [ "${argv[$a]:0:1}" = '-' ] && invocationQuoted+="${argv[$a]} " || invocationQuoted+="'${argv[$a]}' "; done; elif [ -n "$BASH_VERSION" ]; then if [ "${BASH_ARGC}" -eq 1 ]; then local invocationQuoted="$@"; else for ((a=$((${BASH_ARGC}-2)); a >= 0; a-- )); do [ "${BASH_ARGV[$a]:0:1}" = '-' ] && invocationQuoted+="${BASH_ARGV[$a]} " || invocationQuoted+="'${BASH_ARGV[$a]}' ";done;fi;fi;echo -e "Arguments:\n${uiType} ${invocationQuoted}\n" >&2;fi;[ -n "$outputFlag" ] && (echo "Applescript:" >&2; cat <<< "$APPLESCRIPT" | tr -s ' ' | sed '/^$/d' >&2; echo >&2);if [ -n "${killSystemEventsFlag}" ]; then local sysEventsPID; for sysEventsPID in $(pgrep System\ Events); do eval ${asuserPrefix} kill -9 "${sysEventsPID}"; done; fi; if [ -z "${nonBlockingFlag}" ]; then osaresult=$(eval ${asuserPrefix} /usr/bin/osascript 2>/dev/null <<< "$APPLESCRIPT"); else 
( eval ${asuserPrefix} /usr/bin/osascript &>/dev/null <<< "$APPLESCRIPT"; [ -e "${tempIcon}" ] && rm -f "${tempIcon}" ) &
fi; case "${uiType}" in "alert"|"button"|"text") if grep -q "text returned:" <<< "${osaresult}"; then lastText=$(awk -F 'text returned:|, gave up:' '{print $2}' <<< ${osaresult}); lastButton=$(awk -F 'button returned:|, text returned:' '{print $2}' <<< ${osaresult});else lastButton=$(awk -F 'button returned:|, gave up:' '{print $2}' <<< ${osaresult});fi;lastGaveUp=$(awk -F 'gave up:' '{print $2}' <<< ${osaresult});;"file"*|"folder"|"application"|"color"|"url"|*)lastChoice="${osaresult}";esac;[ -e "${tempIcon}" -a -z "${nonBlockingFlag}" ] && rm -f "${tempIcon}";if [ -n "${variableFlag}" ]; then [ -n "${variableFlagPlus}" ] && echo "osaresult: ${osaresult}" >&2; echo "lastButton=\$'$(sed -e 's/\\/\\\\\\/' -e $'s/\'/\\\\\'/' <<< "${lastButton}")'"; echo "lastText=\$'$(sed -e 's/\\/\\\\\\/' -e $'s/\'/\\\\\'/' <<< "${lastText}")'"; echo "lastChoice=\$'$(sed -e 's/\\/\\\\\\/' -e $'s/\'/\\\\\'/' <<< "${lastChoice}")'"; echo "lastGaveUp=\$'$(sed -e 's/\\/\\\\\\/' -e $'s/\'/\\\\\'/' <<< "${lastGaveUp}")'";fi
}
## END SHUI FUNCTION ##


##########################################################################################
# TEST FUNCTIONS #
##########################################################################################

function button_demo {
	shui button -p "Specify icons by specific file, the .app bundle or with keywords \"stop\", \"caution\", and \"note\"\nDefault buttons can be specified by name or number..." -b "OK,Cool,Cancel" -d "Cool" -t "Your Title Here" -i "/System/Library/CoreServices/Finder.app" -V

	shui button -p "You can specify a cancel button by name (Skip) or number (3)\nCancel will return no button results when clicked " -b "This,That,Skip" -d 1 -c 3 -i "caution" -V

	shui button -p "Specifying a give up time (-g) makes a nice pop-up that alerts but moves on after a while..." -g "10" -b "OK" -d 1 -t "Title" -i "/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/Clock.icns" -V

	multiLineText="You can put lots of text in a window

	• For a list of things to tell a user
	• Please Make sure you realize...
		° This
		° That
		° The other

	\"Cool\", right?"

	#you can use mutliline variables to neatly compose your invocation
	shui button -p "${multiLineText}" -b "Yes,No,Maybe" -t "Greetings" -i "caution" -d "Yes" -V
}

#unencode emoji work just fine also (just not on Jamf)
function 1emoji_demo {
	multiLineText="shui works with Unicode™ and Emoji 

\0342\0234\0205 Dialogs, buttons, pre-fills, etc...

Note: Multibyte emojis in Jamf Pro scripts MUST be encoded, you may reliably use these encoding schemes

UTF-8 \\\\xhh Hex encoding:
\\\\xf0\\\\x9f\\\\x98\\\\x8e = \xf0\x9f\x98\x8e

UTF-8 \\\\0nnn Octal encoding:
\\\\0360\\\\0237\\\\0230\\\\0216 = \0360\0237\0230\0216

Unicode characters can be encoded using jpt the JSON Power Tool: https://github.com/brunerd/jpt
"

	#you can use mutliline variables to neatly compose your invocation
	shui button -p "${multiLineText}" -b "\0360\0237\0237\0242 Yes,\xf0\x9f\x9b\x91 No,\0342\0232\0240\0357\0270\0217Maybe" -t "\xf0\x9f\x93\xa3 Greetings \xf0\x9f\x94\x8a" -i "caution" -d "\xf0\x9f\x9f\xa2 Yes" -V
}

function text_demo {
	shui text -p "Hidden Input with Pre-Filled answer...\nSpecifying an app brings focus and icon keywords will badge the app icon" -h -P "secr3t" -t "Password Prompt" -i "stop" -b "Submit,Cancel" -d 1 -V -a Terminal

	#buttons named cancel are treated special and do not return a button name or anything but our function will return a gave up as false to help
	shui text -p "Question for you, 15 seconds though!\nNote: It will return the pre-fill after timeout, lastGaveUp will be true" -P "Pre-Filled Answer" -t "Title" -i "/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/Actions.icns" -b "Send,Save,Trash" -d 1 -c 3 -g 15 -V

	#buttons named cancel are treated special and do not return a button name or anything but our function will return a gave up as false to help
	shui text -p "You can put commas in buttons if you delimit with newlines\nLack of default button ensures accidentally hitting Return does not move on..." -i "note" -t "Title" -b "OK, Boomer"$'\n'"Cancel" -V
}

function list_demo {
	#first button name is for "OK" button, the second if for the cancel button
	shui list -p "Choose One, custom buttons" -l "This,That,Other" -t "Title"  -b 'Remove,Skip' -P "Other" -V

	#while the list choice demiliters default to comma, you can specify a custom delimiter like LF if you need to used commas
	local bunchaChoices="This has commas, neato!
	This one too, wow"
	shui list -p "Items have commas by using custom delimiter, buttons can include commas if newlines used" -l "$bunchaChoices" -t "Title" -b 'Remove, Please'$'\n''Ignore' -D $'\n' -P "This one too, wow" -V

	#while the list choice demiliters default to comma, you can specify a custom delimiter like space if you want
	local bunchaChoices="true false truthy"
	shui list -p "Choose One or none from space delimited list with custom delimiter" -l "$bunchaChoices" -t "Custom Title" -b 'Pick,Pass' -D " " -e -V

	#a single button name will be used for the "OK" button
	shui list -p "Choose One or More (Custom Buttons) with Shift or Command clicking" -m -l "Eenie,Meanie,Minie,Moe" -t "Title" -b 'Choose' -P "Eenie,Moe" -V

	#buttons default to "OK, Cancel"
	shui list -p "Choose One or More with Shift or Command clicking" -m -l "This,That,Other" -t "Title" -V

	#allowing commas in a list mean changing the delimiter to $'\n' from ,
	local bunchaChoices="This has commas, neato!
	This one too, wow
	I will forget Applescript after using this"
	shui list -p "Choose One or More (Custom buttons) with Shift or Command clicking" -m -l "$bunchaChoices" -t "Title" -b 'Yep,Nope' -D $'\n' -V
}

function file_demo {
	#pick a file or folder, defaults to where the script is running
	shui file -p "Pick a file inside an app or package bundle" -d '/System/Library/CoreServices' -s -V

	#pick a file or folder, defaults to where the script is running
	shui file -p "Pick a hidden file..." -h -d '~' -V

	#pick a file or folder, defaults to where the script is running
	shui file  -p "Pick multiple files using Shift and Command keys..." -m -V

	#specify allowed mixed UTI file extensions (-f) and a default folder to look with (-d)
	shui file -p "Pick a public.image or txt file only" -m -P 'public.image,txt' -d '~/Pictures' -V

	#specify an allowed file extension (-f) and a folder to look with (-t)
	shui file -p "Pick a .log or .out files only" -m -P 'log,out' -d "/var/log" -V
}

function folder_demo {
	#pick multiple folders, will resolve ~ relative paths for the console user
	shui folder -p "Pick some folders from your Desktop..." -m -d '~/Desktop' -V

	#specify an a default directory to look in with -d and inside
	shui folder -p "Pick a folder inside an Application" -s -d "/Applications" -V

	#pick a file or folder, defaults to where the script is running
	shui folder -p "Pick a folder, origin of current script if not specified..." -h -V

	#specify a default directory to look in with -d 
	shui folder -p "Pick folders starting at root" -m -d "/" -V
}

function alert_demo {
	shui alert -p "Alert Prompt" -P "Alerts do not have titles, the prompt text will be bolder though\nThe icon will be the application specified with -a or a folder if no application is specified\nThis is an info/warning level alert (default)..." -b "OK" -d 1 -V

	shui alert -p "Bold Alert Prompt" -P "The critical alert level overlays the application icon with a caution sign" -b "This,That,Cancel" -d 1 -c 3 -L "critical" -V

	shui alert -p "Specify an application with the -a option" -P "The icon is jazzed up but this will inhibit any other action in the app until dismissed and may require additional PPPC permissions" -b "OK," -d 1 -a "Terminal" -L "critical" -V
}

function znonBlockingButton_demo {
	#timeout
	shui button -a "System Events" -p "Non-blocking window (-n) with give up of 10 seconds, the script proceeds (not blocked) and no values are returned\n\nNote: Give up time will affect subsequent System Events windows if this is still open...\n" -b "Wait for it..." -g 10 -i "caution" -n -V
	echo "Script proceeding, sleeping 5 seconds..."
	sleep 5
	shui button -a "System Events" -p "Like this one...\nThis one will get the time out from the previous window, so only specify -a \"System events\" if you want to be able to kill the non-blocking window later..." -b "Uh oh" -g 10 -i "caution" -V
	echo "Script proceeding, sleeping 5 seconds..."
	sleep 5
	shui button -a "System Events" -p "This window is now covering a window that is stuck... and this has a give up of 1 hour BUT it can be killed along with all other System Events based windows with -X\n\nWait for it... (10 seconds)" -b "Wait for it..." -g 3600 -i "stop" -d 1 -n -V
	echo "Script proceeding, sleeping 10 seconds..."
	sleep 10
	shui button -p 'BOOM!\nPrevious windows with System Events as the application can be cleared with -X\n' -X -b "OK" -V -N -i "/System/Library/CoreServices/Finder.app"
	echo "Script proceeding, sleeping 5 seconds..."
	sleep 5
	shui alert -p "Alerts can be non-Blocking too" -P "They sure can...\n\nIf you specify any other app besides System Events with -a they cannot be killed with -X" -N  -L "critical" -B 1 -X
	echo "Script proceeding, sleeping 7 seconds..."
	sleep 7
}

function application_demo {
	#timeout
	shui application -p "Pick one application..." -t "App Picker" -V

	#timeout
	shui application -p "Pick one or more applications using the Shift and Command keys..." -m -t "Multi-App Picker" -V
}

function url_demo {
	#URL defaults to "file" servers if no service specified (-S)
	shui url -V

	#URL with service specified
	shui url -S "web" -V
}

function color_demo {
	shui color -V

	shui color -P "12000,30000,45000" -V
}

function filename_demo {
	#pick a file or folder, defaults to where the script is running
	shui filename -p "Pick a file name to Save As..." -d '~/Desktop' -P "PrePopulated_Name-$RANDOM.txt" -V
}

function Q_and_A_demo {
	shui text -p 'Hi! What is your name?' -d "OK" -t "shui demo" -V
	local myName="${lastText:-Unknown}"

	shui button -p "Good to meet you ${myName}, which do you prefer?" -b "Day,Night,Both" -V
	local timeOfDayPref="${lastButton}"

	shui list -p "Are any of these are your favorite fruits?" -l "Apples,Bananas,Blueberries,Kiwi Fruit,Jack Fruit,Durian,Sugar Cane" -m -V -e
	local myFruitsRAW="${lastChoice}"
	#count the lines, ensure line is not empty as the wc -l method always return 1 or greater, otherwise it is zero
	[ -n "${myFruitsRAW}" ] && local myFruitsLines=$(wc -l <<< "$(sed -e '/^$/d' <<< "$myFruitsRAW")" | sed -e 's/^[ ]*//g') || local myFruitsRAW=0

	if [ "${myFruitsLines}" -eq 0  ]; then
		s=""
		isare="is"
		myFruits="None"
	elif [ "${myFruitsLines}" -eq 1  ]; then
		s=""
		isare="is"
		myFruits="${myFruitsRAW}"
	else
		s="s"
		isare="are"
		myFruits=$(sed -e :a -e N -e '$!ba' -e 's/\n/, /g'<<< "${myFruitsRAW}")
	fi

	shui alert -p "Here are my findings, $myName" -P "Your preference of day or night is: $timeOfDayPref
	Your favorite fruit${s} ${isare}: ${myFruits}" -b "OK" -d 1
}

function testMenu {
	#path to this script in zsh
	if [ -e "${ZSH_ARGZERO}" ]; then
		local myPath="${ZSH_ARGZERO}"
	#in bash this will be the script (in zsh this is the function name)
	elif [ -e "${0}" ]; then
		local myPath="$0"
	fi

	#build our list
	testFunctionsList=$(grep ^function "${myPath}" | grep _demo | awk '{print $2}' | sort -df)
	while :; do
		shui list -D "LF" -l "${testFunctionsList}" -b "Run,Exit" -p "Pick one or more test functions to run..." -t "shui" -m -X
		#if it's empty quit otherwise invoke the function
		if [ -z "${lastChoice}" ]; then
			exit
		else
			for function in ${lastChoice}; do
				"$function"
			done
		fi
	done
}

function defaults_demo {
	#we can use these global vars to set defaults (or hardcode them in the function)
	shui_defaultOption="That"
	shui_defaultTitle="Default Title"
	shui_defaultIcon="/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/Clock.icns"
	
	shui button -p "Specifying a default button, title, and icon via global variables..." -b "This,That,Other" -V
}

########
# MAIN #
########

case ${1} in

"menu"|"demo")
	#make a menu of all the test functions
	testMenu
	;;
*)
	#pass-through all arguments
	shui "$@"
	;;
esac
